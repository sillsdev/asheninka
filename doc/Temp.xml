<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE xlingpaper PUBLIC "-//XMLmind//DTD XLingPap//EN"
"XLingPap.dtd">
<xlingpaper
version="2.24.0"
><styledPaper
><lingPaper
automaticallywrapinterlinears="yes"
useImageWidthSetToWidthOfExampleFigureOrChart="no"
version="3.8.0"
><frontMatter
><title
></title
><author
></author
></frontMatter
><section1
id="sNuclearProjectionApproach"
><secTitle
><object
type="tNPApproach"
></object
></secTitle
><p
><indexedItem
term="iNuclearProjectionApproach"
></indexedItem
>For the <object
type="tNPApproach"
></object
>, you need to define the following items:</p
><ol
><li
>segments (<sectionRef
sec="sNPSegmentInventory"
></sectionRef
>)</li
><li
>a sonority hierarchy via natural classes (<sectionRef
sec="sNPSonorityHierarchy"
></sectionRef
>)</li
><li
>syllabification parameters (<sectionRef
sec="sNPSyllabificationParameters"
></sectionRef
>)</li
><li
>CV Natural Classes <sectionRef
sec="sNPCVNaturalClasses"
></sectionRef
>)</li
><li
><object
type="tNPRules"
></object
> (<sectionRef
sec="sNPRules"
></sectionRef
>)</li
><li
>grapheme natural classes (<sectionRef
sec="sNPGraphemeNaturalClasses"
></sectionRef
>)</li
><li
>environments (<sectionRef
sec="sNPEnvironments"
></sectionRef
>)</li
></ol
><p
>If needed to successfully parse your language, you may also need to define <object
type="tNPFilters"
></object
> <sectionRef
sec="sNPFilters"
></sectionRef
>).</p
><p
>After that, you either use a existing word list, import a word list (see <sectionRef
sec="sWords"
></sectionRef
>) or enter a list of words by hand. <indexedItem
term="iParseAllWords"
></indexedItem
>Then you use the <object
type="tMenuItem"
>Parser / Parse all Words </object
> menu item or click on the <img
XeLaTeXSpecial="scaled='500'"
src="resources/SyllabifyWords.png"
></img
> tool bar button. This will apply the algorithm of the <object
type="tNPApproach"
></object
> to all the words. You can then see the results in the <object
type="tNPWords"
></object
> view. See <sectionRef
sec="sNPWords"
textBefore="plural"
></sectionRef
> and <sectionRef
sec="sNPTryAWord"
textBefore="none"
></sectionRef
> for ideas on how to check the results, among other things.</p
><p
>The main “game” to play with the <object
type="tNPApproach"
></object
> in <object
type="tAsheninka"
></object
> is to adjust the segment inventory (including graphemes and their environments), the sonority hierarchy (i.e., its ordered set of natural classes), the syllabification parameters, and the <object
type="tNPRules"
></object
> so that one gets most, if not all, words to syllabify correctly. You may also need to write <object
type="tNPFilters"
></object
> to get some words to parse.</p
><p
>In rough terms, it tries to find all possible sequences of segments in the word. If it can do that, it then seeks to apply each rule in turn. If every segment in the word is in a syllable, then it considers the parse a success. See appendix <appendixRef
app="aNPAlgorithm"
></appendixRef
> for details.</p
><p
>We now give more information on the various views available in the user interface for the <object
type="tNPApproach"
></object
>.</p
><section2
id="sNPSegmentInventory"
><secTitle
>NP segment inventory</secTitle
><p
><indexedItem
term="iNPSegments"
></indexedItem
>The <object
type="tNPSegmentInventory"
></object
> view works exactly like the <object
type="tCVSegmentInventory"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sCVSegmentInventory"
></sectionRef
> for details.</p
></section2
><section2
id="sNPSonorityHierarchy"
><secTitle
>Sonority hierarchy</secTitle
><p
><indexedItem
term="iNPSonorityHierarchy"
></indexedItem
>The <object
type="tNPSonorityHierarchy"
></object
> view works exactly like the <object
type="tSHSonorityHierarchy"
></object
> view does for the <object
type="tSHApproach"
></object
>. See <sectionRef
sec="sSHSonorityHierarchy"
></sectionRef
> for details.</p
></section2
><section2
id="sNPSyllabificationParameters"
><secTitle
>Syllabification parameters</secTitle
><p
><indexedItem
term="iNPSyllabificationParameters"
></indexedItem
><indexedItem
term="iSyllabificationParameters"
></indexedItem
>The <object
type="tSyllabificationParameters"
></object
> view is where you set the parameters to control syllabification for your language. To read more about these parameters, you can click <link
href="Overview.pdf"
>here</link
> or use the <object
type="tMenuItem"
>Help / Introduction to syllabification</object
> menu item. The <object
type="tNPApproach"
></object
> has only one parameter:</p
><p
><indexedItem
term="iOnsetPrinciple"
></indexedItem
>The <object
type="tField"
>Onset principle</object
> field has three radio buttons. One of them must be set. The three options are:</p
><ol
><li
><indexedItem
term="iAllButFirst"
></indexedItem
>All but the first syllable must have an onset</li
><li
><indexedItem
term="iEverySyllable"
></indexedItem
>Every syllable must have an onset</li
><li
><indexedItem
term="iOnsetsNotRequired"
></indexedItem
>Onsets are not required</li
></ol
><p
>The other two parameters are controlled by the <object
type="tNPRules"
></object
>:</p
><ul
><li
><indexedItem
term="iCodasAllowed"
></indexedItem
>Whether codas are allowed or not is controlled by having coda-oriented rules or not having them.</li
><li
><indexedItem
term="iOnsetMaximization"
></indexedItem
>Onset maximization is controlled by ordering onset-oriented rules before any coda rules.</li
></ul
></section2
><section2
id="sNPCVNaturalClasses"
><secTitle
>CV natural classes</secTitle
><p
>The <object
type="tCVNaturalClasses"
></object
> view is exactly the same as the <object
type="tCVNaturalClasses"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See section <sectionRef
sec="sCVNaturalClasses"
></sectionRef
> for details.</p
></section2
><section2
id="sNPRules"
><secTitle
>NP Rules</secTitle
><p
><object
type="tNPRules"
></object
> drive the syllabification process in the <object
type="tNPApproach"
></object
>. Typically, at least two to five rules need to be defined. The first one must always be one that builds a nucleus and all the needed structure and is usually built on vowels. The other rules tend to add other segments to this.</p
><p
>When defining a <object
type="tNPRule"
></object
>, you fill in the fields. The “Name” field is for you to remember this rule.</p
><p
>Its "Description” field lets you define it more fully, perhaps including some example words as to why you added the rule if it is not one of the standard rules.</p
><p
>The “Affected” field lets you select the segment or natural class that the rule applies to.</p
><p
>The “Context” field lets you select the segment or natural class that must occur before or after the affected item.</p
><p
>The “Action” drop-down chooser lets you select the kind of action the rule has. There are five possible values as shown in example <exampleRef
letter="xRuleActions"
num="xRuleActions"
></exampleRef
>.</p
><example
num="xRuleActions"
><table
border="1"
><tr
><th
>Action</th
><th
>Description</th
></tr
><tr
><td
><object
type="tNPRuleActionAttach"
></object
></td
><td
>Attach the affected segment at the node level of the rule. This rule is applied only once per syllable.</td
></tr
><tr
><td
><object
type="tNPRuleActionAugment"
></object
></td
><td
>Augment the affected segment at the node level of the rule. This rule can be applied more than once per syllable.</td
></tr
><tr
><td
><object
type="tNPRuleActionBuild"
></object
></td
><td
>Build the initial nodes. The affected segment will be at the <object
type="tNPRuleLevelN"
></object
> which will be in an <object
type="tNPRuleLevelNBar"
></object
> node which will be in an <object
type="tNPRuleLevelNDoubleBar"
></object
> node which is the first item in a syllable.</td
></tr
><tr
><td
><object
type="tNPRuleActionLeftAdjoin"
></object
></td
><td
>Adjoin the affected segment to the left of the context segment at the indicated node level.</td
></tr
><tr
><td
><object
type="tNPRuleActionRightAdjoin"
></object
></td
><td
>Adjoin the affected segment to the right of the context segment at the indicated node level.</td
></tr
></table
></example
><p
>The “Level” drop-down chooser lets you select the rule node level of the rule. There are four possible values as shown in example <exampleRef
letter="xRuleLevels"
num="xRuleLevels"
></exampleRef
>.</p
><example
num="xRuleLevels"
><table
border="1"
><tr
><th
>Level</th
><th
>Description</th
></tr
><tr
><td
><object
type="tNPRuleLevelAll"
></object
></td
><td
>This indicates the rule will build all the levels.</td
></tr
><tr
><td
><object
type="tNPRuleLevelN"
></object
></td
><td
>This is the nucleus level.</td
></tr
><tr
><td
><object
type="tNPRuleLevelNBar"
></object
></td
><td
>This is the rime level.</td
></tr
><tr
><td
><object
type="tNPRuleLevelNDoubleBar"
></object
></td
><td
>This is the top level to which onsets are attached.</td
></tr
></table
></example
><p
XeLaTeXSpecial="pagebreak"
>The “Obeys SSP” check box indicates whether or not the affected item and the context item must obey the Sonority Sequencing Principle.</p
><p
>Example <exampleRef
letter="xStandardRules"
num="xStandardRules"
></exampleRef
> below lists the standard five rules.</p
><example
num="xStandardRules"
><table
border="1"
><tr
><th
width="1.35in"
>Rule</th
><th
width=".75in"
>Affected</th
><th
width=".6in"
>Context</th
><th
width=".75in"
>Action</th
><th
width=".45in"
>Level</th
><th
width=".7in"
>Diagram</th
></tr
><tr
><td
>Nucleus</td
><td
>[V]</td
><td
> </td
><td
><object
type="tNPRuleActionBuild"
></object
></td
><td
><object
type="tNPRuleLevelAll"
></object
></td
><td
><img
XeLaTeXSpecial="scaled='1000' vertical-adjustment='-6pt' "
src="LingTreeDiagrams/NPNucleusRule.svg"
></img
></td
></tr
><tr
><td
>Onset</td
><td
>[C]</td
><td
>[V]</td
><td
><object
type="tNPRuleActionAttach"
></object
></td
><td
><object
type="tNPRuleLevelNDoubleBar"
></object
></td
><td
><img
XeLaTeXSpecial="scaled='1000' vertical-adjustment='-6pt' "
src="LingTreeDiagrams/NPOnsetRule.svg"
></img
></td
></tr
><tr
><td
>Coda</td
><td
>[C]</td
><td
>[V]</td
><td
><object
type="tNPRuleActionAttach"
></object
></td
><td
><object
type="tNPRuleLevelNBar"
></object
></td
><td
><img
XeLaTeXSpecial="scaled='1000' vertical-adjustment='-6pt' "
src="LingTreeDiagrams/NPCodaRule.svg"
></img
></td
></tr
><tr
><td
>Augmented onsets</td
><td
>[C]</td
><td
>[C]</td
><td
><object
type="tNPRuleActionAugment"
></object
></td
><td
><object
type="tNPRuleLevelNDoubleBar"
></object
></td
><td
><img
XeLaTeXSpecial="scaled='1000' vertical-adjustment='-6pt' "
src="LingTreeDiagrams/NPOnsetAugmentRule.svg"
></img
></td
></tr
><tr
><td
>Augmented codas</td
><td
>[C]</td
><td
>[C]</td
><td
><object
type="tNPRuleActionAugment"
></object
></td
><td
><object
type="tNPRuleLevelNBar"
></object
></td
><td
><img
XeLaTeXSpecial="scaled='1000' vertical-adjustment='-6pt' "
src="LingTreeDiagrams/NPCodaAugmentRule.svg"
></img
></td
></tr
></table
></example
><p
><indexedItem
term="iEnglish"
></indexedItem
>Example <exampleRef
letter="xFiltersEnglish"
num="xFiltersEnglish"
></exampleRef
> has some examples from an English project. They are all repair filters. <indexedItem
term="iQuiegolaniZapotec"
></indexedItem
>Example <exampleRef
letter="xFiltersZPI"
num="xFiltersZPI"
></exampleRef
> has an example from Quiegolani Zapotec which makes use of the context in the preceding syllable ([Obs] is a class of obstruents).</p
><example
num="xFiltersEnglish"
><table
border="1"
><tr
><th
>Type</th
><th
>Slots</th
><th
>Description</th
></tr
><tr
><td
>Onset</td
><td
>[Non-stridentCoronal] | l</td
><td
>Disallow non-strident coronal before labial in an onset. Example: <langData
lang="lIPA"
>ætlæntɪk</langData
> (<langData
lang="lEnglishExmple"
>Atlantic</langData
>) should be <langData
lang="lIPA"
>æt.læn.tɪk</langData
>, not <langData
lang="lIPA"
>æ.tlæn.tɪk</langData
>.</td
></tr
><tr
><td
> </td
><td
> </td
><td
> </td
></tr
><tr
><td
>Onset</td
><td
>[Stop] | [N]</td
><td
>Disallow stop/nasal in a onset. Example: <langData
lang="lIPA"
>æpniə</langData
> (<langData
lang="lEnglishExmple"
>apnea</langData
>) should be <langData
lang="lIPA"
>æp.ni.ə</langData
>, not <langData
lang="lIPA"
>æ.pni.ə</langData
>.</td
></tr
><tr
><td
> </td
><td
> </td
><td
> </td
></tr
><tr
><td
>Onset</td
><td
>[Labial] | [Labial]</td
><td
>Disallow two labials in an onset. Exampleː <langData
lang="lIPA"
>ʃapwoɹn</langData
> (<langData
lang="lEnglishExmple"
>shopworn</langData
>) should be <langData
lang="lIPA"
>ʃap.woɹn</langData
>, not <langData
lang="lIPA"
>ʃa.pwoɹn</langData
>.</td
></tr
></table
></example
><example
num="xFiltersZPI"
><table
border="1"
><tr
><th
>Type</th
><th
>Slots</th
><th
>Description</th
></tr
><tr
><td
>Onset</td
><td
>[V] [Sonorant] _ *[Obs] | ([Sonorant]) *[Obs]</td
><td
>Disallow an obstruent before another obstruent in an onset when the preceding syllable's rime contains a vowel and a sonorant. Example: <langData
lang="lZPI"
>baanske</langData
> (<langData
lang="lEnglishExmple"
>sadly</langData
>) should be <langData
lang="lZPI"
>baans.ke</langData
>, not <langData
lang="lZPI"
>baan.ske</langData
>.</td
></tr
></table
></example
><p
>Finally, the order in which the filters occur is important. The items are in order of priority: the first to be tried (of a given scope) is higher and the last to be tried (of that scope) is lower. You control the order of the filters by clicking on a filter in the middle pane and then using the up and down arrows to change its order. Note that the normal way of sorting by a column via clicking on a column header is disabled for this view.</p
><p
></p
></section2
><section2
id="sNPFilters"
><secTitle
>NP filters</secTitle
><p
><indexedItem
term="iNPFilter"
></indexedItem
>The set of filters for the <object
type="tNPApproach"
></object
> is a completely different set of filters from those used by the <object
type="tONCApproach"
></object
> and the <object
type="tMoraicApproach"
></object
>. <object
type="tNPFilters"
></object
> can be used for onsets, codas, and rimes in <object
type="tAsheninka"
></object
> with the <object
type="tNPApproach"
></object
>. More precisely, <object
type="tNPFilters"
></object
> are applied to rules whose <object
type="tNPRuleLevel"
></object
> is either <object
type="tNPRuleLevelNBar"
></object
> or <object
type="tNPRuleLevelNDoubleBar"
></object
>. Every <object
type="tNPFilter"
></object
> is a fail filter. There are no repair filters in the <object
type="tNPApproach"
></object
>.</p
><p
>You define filters in a similar way to the filters for the <object
type="tONCApproach"
></object
> and <object
type="tMoraicApproach"
></object
>. See <sectionRef
sec="sONCFilters"
></sectionRef
> for more on using filters.</p
><p
>One other difference is that for <object
type="tNPFilters"
></object
>, you can use the underscore character ( _ ) at the point before the first segment or class which is being attached or augmented. For example, in an English IPA project, there is an <object
type="tNPFilter"
></object
> which fails whenever an alveo-palatal is to be added before a sonorant. This is to handle cases like <langData
lang="lIPA"
>kæʃlɛs</langData
> (<langData
lang="lEnglishExmple"
>cashless</langData
>) which should be syllabified as <langData
lang="lIPA"
>kæʃ.lɛs</langData
>, not as <langData
lang="lIPA"
>kæ.ʃlɛs</langData
> and <langData
lang="lIPA"
>maɹʃlænd</langData
> (<langData
lang="lEnglishExmple"
>marshland</langData
>) which should be syllabified as <langData
lang="lIPA"
>maɹʃ.lænd</langData
>, not <langData
lang="lIPA"
>maɹ.ʃlænd</langData
>. As an initial attempt, we might write this fllter as in example <exampleRef
letter="xNPFilterPlain"
num="xNPFilterPlain"
></exampleRef
>. This says that when we are about to add a segment that is a member of the Alveo-palatal class and is immediately followed by a segment which is a member of the Sonorant class, do not add it.</p
><example
num="xNPFilterPlain"
><chart
>[Alveo-palatal] [Sonorant]</chart
></example
><pc
>If we write this onset filter like this, we will discover that words such as <langData
lang="lIPA"
>ʃɹəb</langData
> (<langData
lang="lEnglishExmple"
>shrub</langData
>) will fail to syllabify (the filter blocks adding <langData
lang="lIPA"
>ʃ</langData
> as an onset). To overcome this, we can write the filter as in example <exampleRef
letter="xNPFilterConstituent"
num="xNPFilterConstituent"
></exampleRef
></pc
><example
num="xNPFilterConstituent"
><chart
>*[V] (*[Sonorant]) _ [Alveo-palatal] [Sonorant]</chart
></example
><pc
>What comes before the underscore is the preceding context (a vowel with an optionally following sonorant. Since a word like <langData
lang="lIPA"
>ʃɹəb</langData
> does not meet this context, the filter will not block the <langData
lang="lIPA"
>ʃ</langData
> being added as an onset. Notice that for both <langData
lang="lIPA"
>kæʃlɛs</langData
> and <langData
lang="lIPA"
>maɹʃlænd</langData
>, the context is met and so the filter does block adding the <langData
lang="lIPA"
>ʃ</langData
> as desired.</pc
></section2
><section2
id="sNPWords"
><secTitle
>NP words</secTitle
><p
><indexedItem
term="iNPWords"
></indexedItem
>This works like the <object
type="tCVWords"
></object
> view for the <object
type="tCVPatternApproach"
></object
>, except that the <object
type="tPredictedSyllableBreaks"
></object
> values, the <object
type="tParserResult"
></object
> values, and the <object
type="tParserTreeDiagram"
></object
> are the result of the <object
type="tNPApproach"
></object
> algorithm. If the parse fails and some word structure was built, then this partial word structure is shown by <object
type="tParserTreeDiagram"
></object
>. In the tree diagram, a syllable always has onsets attached to <object
type="tNPRuleLevelNDoubleBar"
></object
>, a nucleus attached to <object
type="tNPRuleLevelN"
></object
> and codas attached to <object
type="tNPRuleLevelNBar"
></object
>. Any adjoined segments will show the adjoined level. See <sectionRef
sec="sCVWords"
></sectionRef
> for more on this view.</p
></section2
><section2
id="sNPPredicitedVsCorrect"
><secTitle
>Predicted vs.​ correct Moraic words</secTitle
><p
><indexedItem
term="iNPPredictedVsCorrect"
></indexedItem
><indexedItem
term="iNPPredictedSyllabificationCompare"
></indexedItem
>The <object
type="tNPPredictedVsCorrectWords"
></object
> view shows any words which have both a predicted value and a correct value and, in addition, the two values differ. This is intended to give you a way to quickly see how the results of applying the <object
type="tNPApproach"
></object
> differ from the expected results. In this view the predicted and correct words are aligned in pairs with the predicted syllabification immediately above the correct syllabification. This is an attempt to make it easier to see the differences between the two.</p
></section2
><section2
id="sNPGraphemeNaturalClasses"
><secTitle
>Grapheme natural classes</secTitle
><p
><indexedItem
term="iNPGraphemes"
></indexedItem
>This works exactly like the <object
type="tGraphemeNaturalClasses"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sGraphemeNaturalClasses"
></sectionRef
> for details.</p
></section2
><section2
id="sNPEnvironments"
><secTitle
>Environments</secTitle
><p
><indexedItem
term="iNPEnvironments"
></indexedItem
>This works exactly like the <object
type="tEnvironments"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sEnvironments"
></sectionRef
> for details.</p
></section2
><section2
id="sNPTryAWord"
><secTitle
>NP Try a Word</secTitle
><p
><indexedItem
term="iNPTryAWord"
></indexedItem
><indexedItem
term="iTryAWord"
></indexedItem
>There are times when it may be difficult to know just why a given word is not syllabifying correctly. That's where the <object
type="tTryAWord"
></object
> dialog box can be useful. To see it, use the <object
type="tMenuItem"
>Parser / Try a Word</object
> menu item. This brings up a dialog box like the one shown in example <exampleRef
letter="xMoraicTryAWord"
num="xMoraicTryAWord"
></exampleRef
>. Unlike most dialog boxes, you can keep the <object
type="tTryAWord"
></object
> dialog box open while still editing other views in the main window. Unfortunately, the minimize button does not currently work so you cannot minimize the dialog, but you can drag it around and resize it. Further, the size and location of the <object
type="tTryAWord"
></object
> dialog box for the <object
type="tCVPatternApproach"
></object
>, <object
type="tSHApproach"
></object
>, the <object
type="tONCApproach"
></object
>, and the one for the <object
type="tMoraicApproach"
></object
> can be set independently; you can have several <object
type="tTryAWord"
></object
> dialog boxes open at the same time if you wish.</p
><example
num="xNPTryAWord"
><chart
><img
src="resources/CVTryAWord1.png"
width="500"
></img
></chart
></example
><p
>You can key a word to try in the text box. By default, <object
type="tAsheninka"
></object
> shows the current word selected in the <object
type="tMoraicWords"
></object
> view (if you are showing that view), the current word selected in the <object
type="tMoraicPredictedVsCorrectWords"
></object
> view (if you are showing that view) or the last word you used (or nothing if you've never used <object
type="tTryAWord"
></object
> before and are not showing the <object
type="tMoraicWords"
></object
> view).</p
><p
>When you either press the <object
type="tKey"
>Enter</object
> key or click on the <object
type="tButton"
>Try it</object
> button, <object
type="tAsheninka"
></object
> will try to parse the word in the text box and report the result in the Results portion of the dialog box.</p
><p
>For the <object
type="tMoraicApproach"
></object
>, there are at most two steps that are tried:</p
><ol
><li
>Parsing into segments.</li
><li
>Parsing segments into syllables (via the moraic algorithm; see appendix <appendixRef
app="aMoraicAlgorithmInDetail"
></appendixRef
> below).</li
></ol
><p
>The results portion always shows the parsing into segments. If this succeeded, then it also shows the parsing of segments into syllables. Successful steps are shown in <object
type="tGreen"
></object
> while unsuccessful ones are shown in <object
type="tRed"
></object
>. An example of a successful parse is shown in example <exampleRef
letter="xMoraicTryAWordahwiyak1"
num="xMoraicTryAWordahwiyak1"
></exampleRef
>.</p
><example
num="xNPTryAWordahwiyak1"
><chart
><img
src="resources/MoraicTryAWord2.png"
width="500"
></img
></chart
></example
><p
><indexedItem
term="iFailureMoraicSegmenter"
></indexedItem
>The parsing into segments part is exactly the same as it is for the <object
type="tCVPatternApproach"
></object
>. If any constituent structure was built during the parse, the tree diagram is also shown. The <object
type="tCategory"
>W</object
> constituent is the word and the <object
type="tCategory"
>σ</object
> constituent indicates a syllable. A syllable will have a <object
type="tCategory"
><object
type="tMora"
></object
></object
> constituent. Onset segments attach to an <object
type="tCategory"
>O</object
> category and other segments attach to a <object
type="tCategory"
><object
type="tMora"
></object
></object
> constituent. Below these are the segment and then its grapheme. If the parse succeeded, then the segments and their graphemes are shown in green. If the parse failed but some of the tree was built, then the segments and their graphemes are shown in red.</p
><p
>Scrolling the results window down shows the last part:</p
><example
num="xNPTryAWordahwiyak2"
><chart
><img
src="resources/MoraicTryAWord3.png"
width="500"
></img
></chart
></example
><pc
>In the last part, it shows the sequence of segment pairs that were found along with their respective natural class and relationship. The <object
type="tBold"
>Relation</object
> column uses mathematical symbols to indicate the relationship as given in example <exampleRef
letter="xMoraicTryAWordRelation"
num="xMoraicTryAWordRelation"
></exampleRef
>.</pc
><example
num="xNPTryAWordRelation"
><table
border="1"
><tr
><th
align="center"
>Relation</th
><th
>Meaning</th
></tr
><tr
><td
align="center"
>&lt;</td
><td
>Segment 1 is less sonorous than segment 2.</td
></tr
><tr
><td
align="center"
>=</td
><td
>Segment 1 is equal in sonority to segment 2.</td
></tr
><tr
><td
align="center"
>&gt;</td
><td
>Segment 1 is more sonorous than segment 2.</td
></tr
><tr
><td
align="center"
>!!!</td
><td
>The segment was not in any natural class.</td
></tr
></table
></example
><pc
>The <object
type="tBold"
>Status</object
> column shows what the algorithm did at that part of the processing. Note that if there is a syllable template and especially if that template includes one or more coda slots, then it is possible that the message will show more segments matching the syllable template than will actually end up being in the syllable.</pc
><p
>As mentioned above, whenever one of the two steps fails, there is an error message shown for that step. Depending on the error and the state of the parser at the time, more steps may or may not be tried. See <sectionRef
sec="sCVTryAWord"
></sectionRef
> for examples where the segments could not be parsed.</p
><p
><indexedItem
term="iFailureMoraicNaturalClasser"
></indexedItem
>If a word contains a segment that is not in any natural class, the moraic results table will end with a row whose <object
type="tBold"
>Relation</object
> column contains “!!!” in red and one of the offending segments will have “(No Natural Class)” after it as shown in example <exampleRef
letter="xMoraicTryAWordNCFailure"
num="xMoraicTryAWordNCFailure"
></exampleRef
>.</p
><example
num="xNPTryAWordNCFailure"
><chart
><img
src="resources/MoraicTryAWordNCFailure.png"
width="500"
></img
></chart
></example
><pc
>In this case, the word was <langData
lang="lVernacular"
>abay</langData
>, but no natural class has the segment <langData
lang="lVernacular"
>b</langData
> in it. So when it tried to find a natural class for <langData
lang="lVernacular"
>b</langData
>, it failed</pc
></section2
></section1
><section1
id="s2"
><secTitle
></secTitle
><p
></p
></section1
><backMatter
><endnotes
></endnotes
><xi:include
href="CommonReferences.xml"
xpointer="element(/1)"
xmlns:xi="http://www.w3.org/2001/XInclude"
></xi:include
></backMatter
><xi:include
href="Languages.xml"
xpointer="element(/1)"
xmlns:xi="http://www.w3.org/2001/XInclude"
></xi:include
><xi:include
href="Types.xml"
xpointer="element(/1)"
xmlns:xi="http://www.w3.org/2001/XInclude"
></xi:include
><xi:include
href="IndexTerms.xml"
xpointer="element(/1)"
xmlns:xi="http://www.w3.org/2001/XInclude"
></xi:include
><contentControl
><contentTypes
><contentType
id="ctSampleData"
>Include sample data sets</contentType
><contentType
id="ctNoSampleData"
>No sample data sets</contentType
></contentTypes
><contentControlChoices
><contentControlChoice
active="no"
>Include sample data sets</contentControlChoice
><contentControlChoice
active="yes"
exclude="ctSampleData"
>Exclude sample data sets</contentControlChoice
></contentControlChoices
></contentControl
></lingPaper
><xi:include
href="SILInternationalPaperStylesheet.xml"
xpointer="element(/1)"
xmlns:xi="http://www.w3.org/2001/XInclude"
></xi:include
></styledPaper
></xlingpaper
>
