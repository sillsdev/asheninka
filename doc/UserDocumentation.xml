<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE xlingpaper PUBLIC "-//XMLmind//DTD XLingPap//EN"
"XLingPap.dtd">
<xlingpaper
version="2.24.0"
><styledPaper
><lingPaper
automaticallywrapinterlinears="yes"
sectionRefCapitalizedPluralLabel="Sections "
sectionRefCapitalizedSingularLabel="Section "
sectionRefDefault="singular"
sectionRefPluralLabel="sections "
sectionRefSingularLabel="section "
version="2.28.0"
><frontMatter
><title
><object
type="tAsheninka"
></object
> User Documentation</title
><author
>H. Andrew Black</author
><affiliation
>SIL International</affiliation
><emailAddress
>asheninka_support@sil.org</emailAddress
><date
>28 June 2021</date
><version
>1.0.0</version
><contents
></contents
></frontMatter
><section1
id="sIntroduction"
><secTitle
>Introduction</secTitle
><p
>The <object
type="tAsheninka"
></object
> program is a linguistic tool with two goals:</p
><ol
><li
>Explore various syllabification algorithms.</li
><li
>Provide a principled way to insert discretionary hyphens in a list of words (which can then be used for typesetting text).</li
></ol
><p
>The first is clearly a linguistic research goal. The second is a practical application of the first goal. While one probably will want to use IPA (<citation
paren="none"
ref="rIPA"
></citation
>) for the first, the second should be done using the practical orthography.</p
></section1
><section1
id="sGeneralUserInterfaceItems"
><secTitle
>General user interface items</secTitle
><p
>This section notes some common items found in various places throughout the user interface. It also discusses some of the more basic <object
type="tMenuItem"
>File</object
>, <object
type="tMenuItem"
>Settings</object
>, and <object
type="tMenuItem"
>Help</object
> menu items.</p
><p
><indexedItem
term="iAddDataItem"
></indexedItem
>While editing data, you add a new item by using the <object
type="tMenuItem"
>Edit / New item</object
> menu item or clicking on the <img
XeLaTeXSpecial="scaled='500'"
src="resources/AddItem.png"
></img
> button. <indexedItem
term="iDeleteDataItem"
></indexedItem
>To delete an item, use the <object
type="tMenuItem"
>Edit / Remove item</object
> menu item or click on the <img
XeLaTeXSpecial="scaled='500'"
src="resources/Remove.png"
></img
> button.</p
><p
><indexedItem
term="iActiveField"
></indexedItem
>A number of these have a field called <object
type="tField"
>Active</object
>. If the checkbox is checked, then this item will be used when syllabifying. If it is not checked, then it will not be used. This lets you experiment with various possibilities.</p
><p
><indexedItem
term="iSorting"
></indexedItem
>When the view contains a pane with rows and columns, you can click on a column header to sort by that column. You can even hold the Shift key down and click on another column header to get a secondary sort (or on a third column to get a tertiary sort). The default sort order is by Unicode code point. See <sectionRef
sec="sLanguages"
></sectionRef
> for how to change the sort order. There are some tables which cannot be sorted because the user controls the order manually. In such cases (such as <object
type="tCVSyllablePatterns"
></object
> and <object
type="tSHSonorityHierarchy"
></object
>), the sorting is disabled.</p
><p
><object
type="tAsheninka"
></object
> will attempt to remember the location and size of the main window, table column widths, and most dialog boxes. So if you find that a dialog box is too small or too large, try resizing it (by dragging the edges of the window). Usually the next time you use that dialog box, it will be at the location and size you changed it to.</p
><section2
id="sNewProject"
><secTitle
>Creating a new project</secTitle
><p
><indexedItem
term="iProjectNew"
></indexedItem
><object
type="tAsheninka"
></object
> comes with a stock set of segments, etc. That is, when you create a new project, <object
type="tAsheninka"
></object
> will fill this new project with this stock set of segments, etc. You can then edit them, delete them, and add any needed items.</p
><p
>When you want to create a new project, use <object
type="tMenuItem"
>File / New Project</object
> menu item or click on the <img
XeLaTeXSpecial="scaled='500'"
src="resources/FileNew.png"
></img
> toolbar button. This brings up a standard “Save as...” dialog box so you can save this stock set of data as your new project. The expected file extension to use with all <object
type="tAsheninka"
></object
> files is “.ashedata” (for <object
type="tAsheninka"
></object
> data). Key the file name you want and press OK.</p
><p
>We suggest you create a directory called “My Asheninka” in your normal documents directory and put all your <object
type="tAsheninka"
></object
> projects in it. You may find it helpful to put each language project in its own directory.</p
></section2
><section2
id="sOpen"
><secTitle
>Opening an existing project</secTitle
><p
><indexedItem
term="iProjectOpen"
></indexedItem
>When you already have an existing <object
type="tAsheninka"
></object
> project and you want to open it into <object
type="tAsheninka"
></object
>, use the <object
type="tMenuItem"
>File / Open Project...</object
> menu item or click on the <img
XeLaTeXSpecial="scaled='500'"
src="resources/FileOpen.png"
></img
> toolbar button. This brings up a standard “File Open...” dialog box. Find the file you want and click on OK.</p
></section2
><section2
id="sSave"
><secTitle
>Saving a project</secTitle
><p
><indexedItem
term="iProjectSave"
></indexedItem
>While <object
type="tAsheninka"
></object
> will automatically save your work about every 30 seconds, you can also use the <object
type="tMenuItem"
>File / Save Project</object
> menu item or click on the <img
XeLaTeXSpecial="scaled='500'"
src="resources/Save.png"
></img
> button in the toolbar.</p
></section2
><section2
id="sSaveAs"
><secTitle
>Save a project as a new project</secTitle
><p
><indexedItem
term="iProjectSaveAs"
></indexedItem
>When you decide to save the current project with a different name, use the <object
type="tMenuItem"
>File / Save Project As...</object
> menu item. The resulting file will have all the data that the original project did except it will have a new name.</p
></section2
><section2
id="sLanguages"
><secTitle
>Setting writing system information for vernacular and analysis language display</secTitle
><p
><indexedItem
term="iLanguageAnalysis"
></indexedItem
><indexedItem
term="iLanguageVernacular"
></indexedItem
><indexedItem
term="iWritingSystems"
></indexedItem
>Use the <object
type="tMenuItem"
>Settings</object
> menu item to set the writing system information for displaying the vernacular and/or the analysis languages. When you choose one of these, the dialog (which is patterned loosely after the writing system dialog in <object
type="tFieldWorks"
></object
>) has three tabs.</p
><section3
id="sWSFontTab"
><secTitle
>Font tab</secTitle
><p
><indexedItem
term="iFonts"
></indexedItem
>The Font tab comes up by default. Click the “Choose font information” button to set the font family, font size, and font style.</p
><p
><indexedItem
term="iColor"
></indexedItem
>Click the drop-down button on the color chooser to change the color from its default value of black.</p
></section3
><section3
id="sWSGeneralTab"
><secTitle
>General tab</secTitle
><p
>There are thee items on this tab.</p
><p
>The language name value is for you to set, should you so wish. It will appear in the main window title if it is not blank.</p
><p
>The language code value is for you to set, should you so wish. It will appear in the main window title if the language name is not blank and this code is not blank.</p
><p
><indexedItem
term="iRightToLeft"
></indexedItem
>The check box is for whether the language is written right-to-left or not. The default is not (i.e., left-to-right).<endnote
id="nRTLAndHyphensAndOrSyllables"
><p
>While we do offer this option, we expect that most right-to-left scripts do not normally use discretionary hyphens and/or are not necessarily orthographically designed to allow showing syllable breaks.</p
></endnote
></p
></section3
><section3
id="sWSSortingTab"
><secTitle
>Sorting tab</secTitle
><p
><indexedItem
term="iSortOrder"
></indexedItem
>The sorting tab has a drop-down chooser box that contains the following options:</p
><ol
><li
>Custom ICU rules</li
><li
>Default order</li
><li
>Same as another language</li
><li
>Use LDML file</li
></ol
><pc
>These are described in the next sections.</pc
><section4
id="sWSCustomICURules"
><secTitle
>Custom ICU rules</secTitle
><p
><indexedItem
term="iICUCustomRules"
></indexedItem
>When this option is chosen, you can key in any custom rules using the ICU rule format.<endnote
id="nICURule"
><p
>See <link
href="https://unicode-org.github.io/icu/userguide/collation/"
>https://​unicode-org.​github.​io/​icu/​userguide/​collation/</link
> and <link
href="https://software.sil.org/fieldworks/wp-content/uploads/sites/38/2016/10/ICU-and-writing-systems.pdf"
>https://​software.​sil.​org/​fieldworks/​wp-content/​uploads/​sites/​38/​2016/​10/ICU-​and-​writing-​systems.pdf</link
>.</p
></endnote
> If you use <object
type="tFieldWorks"
></object
> and have set up ICU rules there, you can copy and paste them into here.</p
><p
>As you type your rules, <object
type="tAsheninka"
></object
> attempts to parse the rules and whenever it finds an error, it gives a message in a box. It shows the approximate location of the error via an exclamation mark before the item. Please note that this appears as you type so if you are in the process of keying a rule, ignore the message until you finish the rule. If there is still a message, try and fix the rule. Whenever an error is found, the “OK” button is disabled so you cannot accidentally save a set of ICU rules with errors.</p
></section4
><section4
id="sWSDefaultOrder"
><secTitle
>Default order</secTitle
><p
><indexedItem
term="iDefaultOrder"
></indexedItem
>When the “Default order" option is chosen, <object
type="tAsheninka"
></object
> will sort items by using Unicode code points. That is, the order is based on the code number assigned to each Unicode character. For languages that use accents or non-A-Z characters, this often is incorrect. To fix it, please use one of the other options.</p
></section4
><section4
id="sWSSameAsAnotherLanguage"
><secTitle
>Same as another language</secTitle
><p
><indexedItem
term="iSameAsAnotherLanguage"
></indexedItem
>Use this option if you need a sort order that is the same as a standard language. <object
type="tAsheninka"
></object
> comes with a large list of such languages and lists them in the “Language to use” drop-down chooser. The languages are given by their standard “locale” abbreviation.<endnote
id="nLanguagesAvailable"
><p
>See <link
href="https://icu4c-demos.unicode.org/icu-bin/locexp/locexp"
>https://icu4c-demos.unicode.org/icu-bin/locexp/locexp</link
> for a list.</p
></endnote
></p
></section4
><section4
id="sWSUseLDMLFile"
><secTitle
>Use LDML file</secTitle
><p
><indexedItem
term="iLDMLFile"
></indexedItem
>A given language's LDML file contains any ICU rules as well as much more information.<endnote
id="nLDML"
><p
>See <link
href="http://www.unicode.org/reports/tr35"
>http://www.unicode.org/reports/tr35</link
> for details.</p
></endnote
> <object
type="tAsheninka"
></object
> currently only uses the ICU rules, if any. If you have used <object
type="tFieldWorks"
></object
> and have set up a sort order for the language you are using <object
type="tAsheninka"
></object
> for and you happen to know where the LDML file is located,<endnote
id="nFLExLDMLFiles"
><p
>In a typical Windows installation, the LDML files are located at C:\​ProgramData\​SIL\​FieldWorks\​Projects\​<object
type="tItalic"
>your_project_name</object
>\​WritingSystemStore.</p
></endnote
> then you can use this option to navigate to that file and select it. <object
type="tAsheninka"
></object
> will then find any ICU rules in it and use them.</p
></section4
></section3
></section2
><section2
id="sHyphenationParameters"
><secTitle
>Setting hyphenation parameters</secTitle
><p
><indexedItem
main="yes"
term="iHyphenationParameters"
></indexedItem
>When one <indexedItem
term="iExport"
></indexedItem
>exports syllabified words in one of three possible formats (as explained in <sectionRef
sec="sWordsExport"
></sectionRef
>), one can also control three variables for each of the three formats:</p
><ol
><li
><indexedItem
main="yes"
term="iHPDiscretionaryHyphen"
></indexedItem
>The discretionary hyphen character sequence used.</li
><li
><indexedItem
main="yes"
term="iHPStart"
></indexedItem
>The number of printable characters from the beginning of the word after which hyphenation starts.</li
><li
><indexedItem
main="yes"
term="iHPStop"
></indexedItem
>The number of printable characters from the end of the word where hyphenation stops.</li
></ol
><p
>The default values for these can be changed by using the <object
type="tMenuItem"
>Settings / Hyphenation Parameters</object
> menu item. This then shows the three export options. Choosing one brings up a dialog box showing the current hyphenation parameter settings for this export method. You can change the values and then click on the <object
type="tMenuItem"
>OK</object
> button.</p
></section2
><section2
id="sUserInterfaceLanguage"
><secTitle
>User interface language</secTitle
><p
><indexedItem
term="iLanguageUI"
></indexedItem
><indexedItem
term="iUIEnglish"
></indexedItem
><indexedItem
term="iUIFrench"
></indexedItem
><indexedItem
term="iUISpanish"
></indexedItem
>You can set the user interface language by using the <object
type="tMenuItem"
>Settings / Change the interface language</object
> menu item. This brings up a dialog box showing the current interface language in a drop down chooser. Click on the chooser's drop down button to see other interface language choices. The choices given use the name of the language in the current interface language followed by the name of the language in its own language. So if the current interface language is English, then it will show “Spanish (español)” as an option; if the current interface language is Spanish, it will show English as “inglés (English)”. When you click on the "OK" button, the program will "flash" and show with the new user interface language.</p
><p
>The current version has English, French<endnote
id="nFrench"
><p
>Many thanks to the folks at <link
href="https://home.missionassist.org.uk/"
>Mission Assist</link
>.</p
></endnote
> and a rough, most likely often inaccurate version of Spanish. Any corrections to any of the languages are welcome.</p
></section2
><section2
id="sHelp"
><secTitle
><object
type="tMenuItem"
>Help</object
> menu items</secTitle
><p
><indexedItem
term="iHelp"
></indexedItem
>Currently, there are five <object
type="tMenuItem"
>Help</object
> menu items:</p
><ol
><li
><indexedItem
term="iUserDoc"
></indexedItem
><object
type="tMenuItem"
>User Documentation</object
> which shows this document.</li
><li
><indexedItem
term="iTutorial"
></indexedItem
><object
type="tMenuItem"
>Suggested Steps</object
> which has some suggestions on how to be effective when using <object
type="tAsheninka"
></object
>.</li
><li
><indexedItem
term="iIntroduction"
></indexedItem
><object
type="tMenuItem"
>Introduction to syllabification</object
> which has some general discussion of syllabification issues.</li
><li
><indexedItem
term="iHamond1997"
></indexedItem
><object
type="tMenuItem"
>Hammond 1997</object
> which opens <citation
ref="rHammond"
></citation
> in your default PDF viewer. If you plan to use the <object
type="tOTApproach"
></object
>, we highly recommend you read at least sections 4-7 before doing so.</li
><li
><object
type="tMenuItem"
>About Asheninka</object
> which has some standard information about the current version of <object
type="tAsheninka"
></object
>.</li
></ol
></section2
><section2
id="sStatusBar"
><secTitle
>Status bar</secTitle
><p
><indexedItem
term="iStatusBar"
></indexedItem
>The bottom row of the window (known as the status bar) contains the current date (at the left). Usually it also contains some numbers at the right. The rightmost pair of numbers is the current index for that view, a slash, followed by the total number of items in that view.</p
><p
>For word views, there are three sets of numbers. From the left they are:</p
><ol
><li
>The number of predicted parses, a slash, the total number of words, and the percentage for that ratio.</li
><li
>The number of predicted parses which equal the correct parse, a slash, the total number of words, and the percentage for that ratio.</li
><li
>The current index, a slash, and the total number of words.</li
></ol
><pc
><indexedItem
term="iParseAllWords"
></indexedItem
>The first two potentially change whenever you parse all words (by using the <object
type="tMenuItem"
>Parser / Parse all Words</object
> menu item or clicking on the <img
XeLaTeXSpecial="scaled='500'"
src="resources/SyllabifyWords.png"
></img
> tool bar button). You can use the first set to help you see potential progress. The second can help you compare how your implementation of a particular approach is doing compared to some other approach.</pc
></section2
></section1
><section1
id="sApproaches"
><secTitle
>Approaches to syllabification</secTitle
><p
><object
type="tAsheninka"
></object
> offers six different syllabification algorithms or approaches. These are covered in <sectionRef
sec="sCVApproach"
textBefore="plural"
></sectionRef
>–<sectionRef
sec="sOTApproach"
textBefore="none"
></sectionRef
>.</p
><p
><indexedItem
term="iIntroduction"
></indexedItem
>The various approaches or algorithms are explained and illustrated in the “Overview” document. You can read this document by clicking <link
href="Overview.pdf"
>here</link
> or by using the <object
type="tMenuItem"
>Help / Introduction to syllabification</object
> menu item.</p
></section1
><section1
id="sCVApproach"
><secTitle
><object
type="tCVPatternApproach"
></object
></secTitle
><p
><indexedItem
term="iCVPatternApproach"
></indexedItem
>In the <object
type="tCVPatternApproach"
></object
>, you need to define the following items:</p
><ol
><li
>segments (<sectionRef
sec="sCVSegmentInventory"
></sectionRef
>)</li
><li
>natural classes (<sectionRef
sec="sCVNaturalClasses"
></sectionRef
>)</li
><li
>syllable patterns (<sectionRef
sec="sCVSyllablePatterns"
></sectionRef
>)</li
><li
>grapheme natural classes (<sectionRef
sec="sGraphemeNaturalClasses"
></sectionRef
>)</li
><li
>environments (<sectionRef
sec="sEnvironments"
></sectionRef
>)</li
></ol
><p
>After that, you import a word list (see <sectionRef
sec="sWords"
></sectionRef
>) or enter a list of words by hand. <indexedItem
term="iParseAllWords"
></indexedItem
>Then you use the <object
type="tMenuItem"
>Parser / Parse all Words </object
> menu item or click on the <img
XeLaTeXSpecial="scaled='500'"
src="resources/SyllabifyWords.png"
></img
> tool bar button. This will apply the algorithm of the <object
type="tCVPatternApproach"
></object
> to all the words. You can then see the results in the <object
type="tCVWords"
></object
> view. See <sectionRef
sec="sCVWords"
textBefore="plural"
></sectionRef
> and <sectionRef
sec="sCVTryAWord"
textBefore="none"
></sectionRef
> for ideas on how to check the results, among other things.</p
><p
>The main “game” to play with the <object
type="tCVPatternApproach"
></object
> in <object
type="tAsheninka"
></object
> is to adjust the segment inventory (including graphemes and their environments), natural classes, and syllable patterns so that one gets most, if not all, words to syllabify correctly.</p
><p
>In rough terms, it tries to find all possible sequences of segments in the word. If it can do that, it then seeks to find a sequence of natural classes that covers the entire sequence of segments. Finally, it tries to find a sequence of syllable patterns that covers the entire sequence of natural classes. See appendix <appendixRef
app="aCVAlgorithmInDetail"
></appendixRef
> for details.</p
><p
>We now give more information on the various views available in the user interface for the <object
type="tCVPatternApproach"
></object
>.</p
><section2
id="sCVSegmentInventory"
><secTitle
>CV segment inventory</secTitle
><p
><indexedItem
term="iCVSegments"
></indexedItem
>Make sure that what is in the <object
type="tCVSegmentInventory"
></object
> view covers all the segments you have in the orthography. <indexedItem
term="iAlgorithmSegment"
></indexedItem
><object
type="tAsheninka"
></object
> tries all graphemes which match at the current point it is looking at in the left-to-right sweep. It tries the longest match first, but also applies any environments associated with the grapheme.</p
><p
>In the <object
type="tField"
>Segment</object
> field, key a letter or letters that will help you remember this segment. For example, a low central unrounded vowel might be keyed as <object
type="tKey"
>a</object
> while a voiceless alveopalatal affricate might be keyed as <object
type="tKey"
>t͡ʃ</object
> or as <object
type="tKey"
>ch</object
>.</p
><p
>The <object
type="tField"
>Description</object
> field is for your benefit. Key whatever helps you (and anyone looking at your data) know what the segment is. For example, you could key its phonetic or phonological description.</p
><p
><indexedItem
term="iCVGraphemes"
></indexedItem
>In the <object
type="tField"
>Graphemes</object
> field, key all the ways the particular segment appears in your orthography, including any upper case forms. Separate each one by a space. When you leave this field (e.g., by clicking in the <object
type="tField"
>Description</object
> field or by pressing the <object
type="tKey"
>Tab</object
> key or using <object
type="tKey"
>Shift-Tab</object
>), <object
type="tAsheninka"
></object
> automatically shows the graphemes in the table at the bottom. You can choose to disable one or more of the graphemes by clicking on the check box in the table at the beginning of the row for the grapheme. You can also select one or more environments where the given grapheme is valid by clicking on the chooser button at the end of the row (see <sectionRef
sec="sEnvironments"
></sectionRef
> and also <sectionRef
sec="sGraphemeNaturalClasses"
></sectionRef
> for more on environments). The chooser button looks like <img
XeLaTeXSpecial="scaled='500'"
src="resources/ChooserButton.png"
></img
>. Note that whenever a given grapheme can occur as more than one segment, then be sure to include the appropriate environments for the grapheme in every such segment.</p
><p
>To remove a grapheme from the table, merely remove it from the <object
type="tField"
>Graphemes</object
> field. Note that when you uncheck a grapheme check box at the beginning of the row, <object
type="tAsheninka"
></object
> will automatically remove that grapheme from the <object
type="tField"
>Graphemes</object
> field. When you check that check box, <object
type="tAsheninka"
></object
> will automatically add it back to the <object
type="tField"
>Graphemes</object
> field. Thus, you can uncheck the box to see what might happen if this grapheme is no longer present. This can be useful when testing environments to condition a grapheme.</p
><p
>It is possible to have the same grapheme occur for more than one segment. If you do this, you may well want to add environments for when each grapheme is valid for a given segment.</p
></section2
><section2
id="sCVNaturalClasses"
><secTitle
>CV natural classes</secTitle
><p
><indexedItem
term="iCVNaturalClasses"
></indexedItem
>Make sure that in the <object
type="tCVNaturalClasses"
></object
> view, every segment is in a natural class. A given segment may be in more than one class.</p
><p
>The <object
type="tField"
>Name</object
> field is for you to define how this natural class will appear in syllable patterns. We suggest using something short and if there is more than one character in it, make the first one be capitalized and the rest be in lower case.<endnote
id="nCVClassName"
><p
>This is not required, it is just a suggestion.</p
></endnote
> While it is possible to use the same name more than once, it will most likely turn out to be confusing. So we recommend you make the name be unique.</p
><p
>The <object
type="tField"
>Description</object
> field is for your use to document anything special about this natural class.</p
><p
>The <object
type="tField"
>Segment or Natural Class</object
> field has a chooser button on the far right which looks like <img
XeLaTeXSpecial="scaled='500'"
src="resources/ChooserButton.png"
></img
>. Click on it to bring up a dialog box which lets you select segments and/or natural classes which belong to this natural class. Note that it is possible to insert one entire natural class within another natural class. For example, if you have a class of nasal consonants, you can include that class within another class that has all consonants.</p
></section2
><section2
id="sCVSyllablePatterns"
><secTitle
>CV syllable patterns</secTitle
><p
><indexedItem
term="iCVSyllablePatterns"
></indexedItem
>Use the <object
type="tCVSyllablePatterns"
></object
> view to create CV syllable patterns that cover the kinds of syllables you think the language has. Be sure to allow for vowel-initial syllables if there are vowel-initial syllables in the language.</p
><p
>The <object
type="tField"
>Name</object
> field is for you to define a short name for this syllable pattern. We suggest using something short. The <object
type="tField"
>Description</object
> field is for your use to document anything special about this syllable pattern.</p
><p
>The <object
type="tField"
>Natural Classes</object
> field shows the sequence of any natural classes this pattern consists of. It has a chooser button on the far right which looks like <img
XeLaTeXSpecial="scaled='500'"
src="resources/ChooserButton.png"
></img
>. Click on it to bring up a dialog box which lets you select natural classes which constitute this syllable pattern. This chooser consists of one or more drop-down boxes. Click on the drop-down arrow in the box. It will show you the list of possible natural classes to choose from. In addition, if this is the very first drop-down box or the last one currently being shown, it will also include “Word boundary”. When you choose “Word boundary”, the pattern shown above the drop-down box(es), will show “#” to indicate a word boundary.</p
><p
>Finally, the order in which the syllable patterns occur is important, as mentioned in <sectionRef
sec="sCVApproach"
></sectionRef
>. Recall that with the <object
type="tCVPatternApproach"
></object
>, as <object
type="tAsheninka"
></object
> parses a word, it tries to match the patterns in the order in which they appear. You control the order of the syllable patterns by clicking on a pattern in the middle pane and then using the up and down arrows to change its order. Note that the normal way of sorting by a column via clicking on a column header is disabled for this view.</p
></section2
><section2
id="sGraphemeNaturalClasses"
><secTitle
>Grapheme natural classes</secTitle
><p
><indexedItem
term="iCVGraphemeNaturalClasses"
></indexedItem
>When your orthography is such that you need to condition some graphemes by one or more environments and you want to capture a generalization about which graphemes can occur around that grapheme via a natural class, then create one or more grapheme natural classes. Note that these are not the same as CV natural classes. The grapheme natural classes are based on the set of graphemes defined in all the segments. The CV natural classes, on the other hand, are defined based on the segments in the segment inventory. The first can be used to determine if a given grapheme is valid for its segment in a given orthographic environment. The second is used to define a class for a segment during the parsing process of a word into syllables.</p
><p
>The <object
type="tField"
>Name</object
> field is for you to define how this grapheme natural class will appear in environments. We suggest using something short and if there is more than one character in it, make the first one be capitalized and the rest be in lower case. The name should be unique among all the grapheme natural classes. If two or more grapheme natural classes share the same name, then any environment which refers to such a grapheme natural class will always use the first one <object
type="tAsheninka"
></object
> happens to find.</p
><p
>The <object
type="tField"
>Description</object
> field is for your use to document anything special about this grapheme natural class.</p
><p
>The <object
type="tField"
>Grapheme or natural class</object
> field has a chooser button (<img
XeLaTeXSpecial="scaled='500'"
src="resources/ChooserButton.png"
></img
>) at the right edge. Clicking on this brings up a chooser where you can select the graphemes and/or other grapheme natural classes that should belong to the grapheme natural class you are defining. Note that it is possible to insert one entire grapheme natural class within another grapheme natural class. For example, if you have a class of nasal consonants, you can include that class within another class that has all consonants.</p
></section2
><section2
id="sEnvironments"
><secTitle
>Environments</secTitle
><p
><indexedItem
term="iCVEnvironments"
></indexedItem
>When your orthography is such that you need to condition some graphemes by one or more environments, you add the environments here. Besides the usual Active check box, there are three fields.</p
><p
>The <object
type="tField"
>Name</object
> field is for you to give a short name for this environment.</p
><p
>The <object
type="tField"
>Description</object
> field is for your use to document anything special about this environment, including why it is needed.</p
><p
>The <object
type="tField"
>Environment</object
> field is where you key the environment. Any error message will appear below the Active check box as you type. (When you create a new environment, this field contains "/ _ " which causes an error message of <object
type="tErrorMessageText"
>A class or a grapheme is missing; detected at or about position 6.</object
> This is because the environment is not valid until it has at least one grapheme, grapheme natural class, or word boundary symbol.)</p
><p
>The content of the <object
type="tField"
>Environment</object
> field follows a special notation. This notation is one that is reminiscent of what is used in many generative-style rules. The basic rules of thumb are:</p
><example
num="xEnvironmentsHowTo"
><chart
><ol
><li
>Begin each environment with the forward slash character <object
type="TT"
>/</object
></li
><li
>The location of the grapheme itself is indicated by an underscore character <object
type="TT"
>_</object
></li
><li
>Any letters or grapheme natural classes that must come before the grapheme are typed in before this underscore character. Type them in the order in which they must appear.</li
><li
>Any letters or grapheme natural classes that must come after the grapheme are typed in after this underscore character. Type them in the order in which they must appear.</li
><li
>Any letter is indicated by typing it the way it appears in the practical orthography.</li
><li
>Any grapheme natural classes are indicated by<ol
><li
>typing a left square bracket <object
type="TT"
>[</object
>,</li
><li
>typing the name of the grapheme natural class,<endnote
id="nNatClassName"
><p
>This is another reason why you should use unique names for grapheme natural classes. If you have two or more grapheme natural classes with the same name, it is not clear which one you mean. <object
type="tAsheninka"
></object
> will automatically select one, but it may not be the one you intended.</p
></endnote
> and</li
><li
>then typing a right square bracket <object
type="TT"
>]</object
></li
></ol
><pc
>When you type a left square bracket, a drop-down box will appear which has the list of grapheme natural class names. You can click on this drop-down box and then click on the name you want to use.<endnote
id="nGraphemeClasDropDown"
><p
>You can also press the <object
type="tKey"
>Tab</object
> key two times to get to the drop-down box. Then use the <object
type="tKey"
>down-arrow</object
> key to move to the one you want and press the <object
type="tKey"
>Enter</object
> key. Please note that currently if you click on the drop-down box with the mouse and then use the <object
type="tKey"
>down-arrow</object
> key, it will choose the first item in the list. I have yet to figure out how to avoid this poor behavior.</p
></endnote
></pc
></li
><li
>Optional letters or grapheme natural classes are indicated by<ol
><li
>typing an opening parenthesis <object
type="TT"
>(</object
>,</li
><li
>typing the letter or grapheme natural class as above, and</li
><li
>then typing a closing parenthesis <object
type="TT"
>)</object
></li
><li
>Note that one should not nest optional items. The <object
type="tAsheninka"
></object
> parser will not handle these properly. You must enter each optional item after the other.</li
></ol
></li
></ol
></chart
></example
><p
>Example <exampleRef
equal="no"
letterOnly="no"
num="xEnvironmentExamples"
></exampleRef
> gives some sample environments along with what they mean.</p
><example
num="xEnvironmentExamples"
><table
border="1"
><tr
><th
align="left"
valign="top"
>Environment    </th
><th
align="left"
valign="top"
>Meaning</th
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ m _</object
></td
><td
align="left"
valign="top"
>after an <object
type="TT"
>m</object
></td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ [V] _</object
></td
><td
align="left"
valign="top"
>after a vowel (assuming there is a grapheme natural class of vowels called <object
type="TT"
>V</object
>)</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ # i _</object
></td
><td
align="left"
valign="top"
>after a word initial <object
type="TT"
>i</object
></td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ # [V] _</object
></td
><td
align="left"
valign="top"
>after a word initial vowel (assuming there is a grapheme natural class of vowels called <object
type="TT"
>V</object
>)</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ [V] y _</object
></td
><td
align="left"
valign="top"
>after a vowel (assuming there is a grapheme natural class of vowels called <object
type="TT"
>V</object
>) and a <object
type="TT"
>y</object
></td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ _ i</object
></td
><td
align="left"
valign="top"
>before an <object
type="TT"
>i</object
></td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ _ [C]</object
></td
><td
align="left"
valign="top"
>before a consonant (assuming there is a grapheme natural class of consonants called <object
type="TT"
>C</object
>)</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ _ y #</object
></td
><td
align="left"
valign="top"
>before a <object
type="TT"
>y</object
> which is word final</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ _ [C] #</object
></td
><td
align="left"
valign="top"
>before a word final consonant (assuming there is a grapheme natural class of consonants called <object
type="TT"
>C</object
>)</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ m _ w</object
></td
><td
align="left"
valign="top"
>between an <object
type="TT"
>m</object
> and a <object
type="TT"
>w</object
></td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ [C] _ [C]</object
></td
><td
align="left"
valign="top"
>between two consonants (assuming there is a grapheme natural class of consonants called <object
type="TT"
>C</object
>)</td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ ai _</object
></td
><td
align="left"
valign="top"
>after an <object
type="TT"
>a</object
> and an <object
type="TT"
>i</object
></td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ _ ai</object
></td
><td
align="left"
valign="top"
>before an <object
type="TT"
>a</object
> and an <object
type="TT"
>i</object
></td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ _ (a)i</object
></td
><td
align="left"
valign="top"
>before an optional <object
type="TT"
>a</object
> and an <object
type="TT"
>i</object
>; that is, either before <object
type="TT"
>ai</object
> or before <object
type="TT"
>i</object
></td
></tr
><tr
><td
align="left"
valign="top"
><object
type="TT"
>/ _ ([C]) #</object
></td
><td
align="left"
valign="top"
>before an optional word final consonant (assuming there is a grapheme natural class of consonants called <object
type="TT"
>C</object
>); that is, either before a word final consonant or word finally</td
></tr
></table
></example
><p
>A given grapheme may have more than one environment, in which case the various environments are logically ORed with each other. That is, if any one of the environments for the grapheme are found, then the grapheme is considered to be valid (as far as its environments are concerned). For example, if a given grapheme can appear either before a consonant or word finally, then you can list both an environment for “before a consonant” and one for “before a word boundary.” Example <exampleRef
equal="no"
letterOnly="no"
num="xSyllableFinalEnvironment"
></exampleRef
> shows what this might look like, assuming that you have a grapheme natural class of consonants with an abbreviation of <object
type="TT"
>C</object
>.</p
><example
num="xSyllableFinalEnvironment"
><table
border="1"
><tr
><td
align="left"
valign="top"
><object
type="TT"
>  / _ [C]  </object
></td
><td
align="left"
valign="top"
><object
type="TT"
> / _ #  </object
></td
></tr
></table
></example
></section2
><section2
id="sCVWords"
><secTitle
>CV words</secTitle
><p
><indexedItem
term="iCVWords"
></indexedItem
>In the <object
type="tCVWords"
></object
> view, the middle pane of the display shows all the words with four other columns:</p
><p
> <comment
>Here to try and get a page break before the list</comment
></p
><p
> <comment
>Here to try and get a page break before the list</comment
></p
><p
> <comment
>Here to try and get a page break before the list</comment
></p
><ol
><li
><object
type="tPredictedSyllableBreaks"
></object
></li
><li
><object
type="tComment"
></object
></li
><li
><object
type="tCorrectSyllableBreaks"
></object
></li
><li
><object
type="tParserResult"
></object
></li
></ol
><pc
>When you click on a word in the middle pane, the same fields are shown on the right where you can edit them. If the parse of the given word is successful, then a tree diagram of the parse is also shown as <object
type="tParserTreeDiagram"
></object
>. The <object
type="tCategory"
>W</object
> constituent is the word and the <object
type="tCategory"
>σ</object
> constituent indicates a syllable. The constituents below the syllable are the natural classes used. Below these are the segment and then its grapheme.</pc
><p
>Please note that until you either manually add words to the project or until you import a set of words, the list will be empty. See <sectionRef
sec="sWordsImport"
></sectionRef
> for how to import a set of words.</p
><p
>The <object
type="tPredictedSyllableBreaks"
></object
> column/field contains the result of the last time you ran the <object
type="tSyllabifyWords"
></object
> tool. When it is empty, it means either that the parser has never been invoked or that the parser failed to produce a result. If the parser failed to produce a result, the <object
type="tParserResult"
></object
> column/field should have some kind of explanation for where the parser ran into a problem (this will be in red).</p
><p
>When the <object
type="tPredictedSyllableBreaks"
></object
> column/field contains a result, it shows how this word was syllabified the last time you ran the <object
type="tSyllabifyWords"
></object
> tool, given the state of the segments, natural classes, and syllable patterns when it was invoked. When there is a result in this column/field, then the <object
type="tParserResult"
></object
> column/field should have “Success” (in green).</p
><p
>Remember that you can click on a column header to sort the contents of the column. If you click on the <object
type="tParserResult"
></object
> header, then any error messages should show at the top. You might find this useful when figuring out how to set the set of segments, natural classes, and syllable patterns to get a desired result.</p
><p
>The <object
type="tCorrectSyllableBreaks"
></object
> column/field contains what you have indicated to be the correct syllabification for this word. It may be filled in if you imported words from a <object
type="tParatext"
></object
> hyphenatedWords.txt file and that file indicated that this word's hyphenation had been approved. See <sectionRef
sec="sRemoveCorrectSyllabifcation"
></sectionRef
> for how to clear the set of <object
type="tCorrectSyllableBreaks"
></object
>. Otherwise, this column/field is expected to be blank until you either manually enter the correct syllabification or run the <object
type="tConvertPredictedToCorrectSyllabifcation"
></object
> tool by using <object
type="tMenuItem"
>Tools / Convert predicted to correct syllabification</object
> menu item or clicking on the <img
XeLaTeXSpecial="scaled='500'"
src="resources/ConvertPredictedToCorrect.png"
></img
> tool bar button.</p
><p
>The <object
type="tComment"
></object
> field is for your use as needed. One possible scenario is to indicate why a given word does not parse. Another, if you are using IPA, is to enter how the word is spelled in the practical orthography.</p
><p
>When you run the <object
type="tConvertPredictedToCorrectSyllabifcation"
></object
> tool, it brings up a dialog box listing all the words which have a non-empty <object
type="tPredictedSyllableBreaks"
></object
> field. See <sectionRef
sec="sConvertPredictedToCorrect"
></sectionRef
> for more on this.</p
></section2
><section2
id="sCVTryAWord"
><secTitle
>CV Try a Word</secTitle
><p
><indexedItem
term="iCVTryAWord"
></indexedItem
><indexedItem
term="iTryAWord"
></indexedItem
>There are times when it may be difficult to know just why a given word is not syllabifying correctly. That's where the <object
type="tTryAWord"
></object
> dialog box can be useful. To see it, use the <object
type="tMenuItem"
>Parser / Try a Word</object
> menu item while in the <object
type="tCVPatternApproach"
></object
>. This brings up a dialog box like the one shown in example <exampleRef
letter="xCVTryAWord"
num="xCVTryAWord"
></exampleRef
>. Unlike most dialog boxes, you can keep the <object
type="tTryAWord"
></object
> dialog box open while still editing other views in the main window. Unfortunately, the minimize button does not currently work so you cannot minimize the dialog, but you can drag it around and resize it. Further, the size and location of the <object
type="tTryAWord"
></object
> dialog box can be set independently for all six approaches; you can have several <object
type="tTryAWord"
></object
> dialog boxes open at the same time if you wish.</p
><example
num="xCVTryAWord"
><chart
><img
src="resources/CVTryAWord1.png"
width="500"
></img
></chart
></example
><p
>You can key a word to try in the text box. By default, <object
type="tAsheninka"
></object
> shows the current word selected in the <object
type="tCVWords"
></object
> view (if you are showing that view), the current word selected in the <object
type="tCVPredictedVsCorrectWords"
></object
> view (if you are showing that view) or the last word you used (or nothing if you've never used <object
type="tTryAWord"
></object
> before and are not showing the <object
type="tCVWords"
></object
> view).</p
><p
>When you either press the <object
type="tKey"
>Enter</object
> key or click on the <object
type="tButton"
>Try it</object
> button, <object
type="tAsheninka"
></object
> will try to parse the word in the text box and report the result in the Results portion of the dialog box.</p
><p
>For the <object
type="tCVPatternApproach"
></object
>, there are at most three steps that are tried:</p
><ol
><li
>Parsing into segments.</li
><li
>Parsing segments into natural classes.</li
><li
>Parsing natural classes into syllables.</li
></ol
><p
>The results portion always shows the parsing into segments. If this succeeded, then it also shows the parsing of segments into natural classes. If this succeeded, it shows the result of parsing natural classes into syllables. Successful steps are shown in <object
type="tGreen"
></object
> while unsuccessful ones are shown in <object
type="tRed"
></object
>. An example of a successful parse is shown in example <exampleRef
letter="xCVTryAWordachinmeh1"
num="xCVTryAWordachinmeh1"
></exampleRef
>.</p
><example
num="xCVTryAWordachinmeh1"
><chart
><img
src="resources/CVTryAWord2.png"
width="500"
></img
></chart
></example
><p
>The parsing into segments part shows which grapheme was matched with what segment, Example <exampleRef
letter="xCVTryAWordGraphemeDiffererent"
num="xCVTryAWordGraphemeDiffererent"
></exampleRef
> shows a case where the grapheme differs from the segment in shape.</p
><example
num="xCVTryAWordGraphemeDiffererent"
><chart
><img
src="resources/CVTryAWordGraphemeDifferent.png"
></img
></chart
></example
><p
>The parsing segments into natural classes part shows which natural classes were matched. Sometimes a given segment may be in more than one natural class. In that case, the possible natural classes are shown inside of curly braces as shown in example <exampleRef
letter="xCVTryAWordMultipleNaturalClasses"
num="xCVTryAWordMultipleNaturalClasses"
></exampleRef
>.</p
><example
num="xCVTryAWordMultipleNaturalClasses"
><chart
><img
src="resources/CVTryAWordMultipleNaturalClasses.png"
></img
></chart
></example
><p
>Scrolling the results window down shows the last part:</p
><example
num="xCVTryAWordachinmeh2"
><chart
><img
src="resources/CVTryAWord3.png"
width="500"
></img
></chart
></example
><pc
>When the parse succeeds, it shows the syllabification as well as a tree diagram indicating the structure of the word parsed into its syllables. The <object
type="tCategory"
>W</object
> constituent is the word and the <object
type="tCategory"
>σ</object
> constituent indicates a syllable. The constituents below the syllable are the natural classes used. Below these are the segment and then its grapheme.</pc
><p
>In the last part, it shows which syllable patterns were tried in the order they were tried. Successful ones are shown in <object
type="tGreen"
></object
> (and begin with a small box with a plus sign in it). These will always be the last one shown because <object
type="tAsheninka"
></object
> stops looking whenever it finds a successful match. Failed ones are shown in <object
type="tRed"
></object
> (and begin with a small box with a minus sign in it). Whenever a particular pattern matched the word at a particular point in the parsing process but it did not ultimately lead to a successful parse, it is shown in <object
type="tBlue"
></object
> (and begins with a small box with a plus sign in it).</p
><p
>To examine a particular path, click on the small box with a plus sign in it. This will expand that path and show the next set of syllable patterns tried, in the order they were tried.</p
><p
>As mentioned above, whenever one of the three steps fails, there is an error message shown for that step (and no following steps will be tried).</p
><p
><indexedItem
term="iFailureCVSegmenter"
></indexedItem
>For example, if a word contains a grapheme that is not defined in any segment, when trying to parse the word into segments, it will show a message such as what is in example <exampleRef
letter="xCVTryAWordGraphemeError"
num="xCVTryAWordGraphemeError"
></exampleRef
>.</p
><example
num="xCVTryAWordGraphemeError"
><chart
><object
type="tErrorMessageText"
>Failure: could not parse into segments beginning at 'qap'.</object
></chart
></example
><pc
>In this case, the word was <langData
lang="lVernacular"
>aanguqap</langData
> but the <langData
lang="lVernacular"
>q</langData
> was not defined in any segment. Note that it shows where the problem was initially found.</pc
><pc
>It will also show the steps it took in trying to parse the word into segments, but failed as in example <exampleRef
letter="xCVTryAWordGraphemeEnvironmentFailure"
num="xCVTryAWordGraphemeEnvironmentFailure"
></exampleRef
>.</pc
><example
num="xCVTryAWordGraphemeEnvironmentFailure"
><chart
><img
src="resources/CVTryAWordGraphemeEnvironmentFailure.png"
></img
></chart
></example
><p
>In this case, the grapheme <langData
lang="lVernacular"
>a̱</langData
> has two environments: either before a vowel or word finally. Neither succeeded.</p
><p
><indexedItem
term="iFailureCVNaturalClasser"
></indexedItem
>As another example, if a word contains a segment that is not in any natural class, it will display a message such as what is shown in example <exampleRef
letter="xCVTryAWordNCFailure"
num="xCVTryAWordNCFailure"
></exampleRef
>.</p
><example
num="xCVTryAWordNCFailure"
><chart
><object
type="tErrorMessageText"
>Failure: could not parse into natural classes; did find classes 'V, C' covering graphemes 'am'.</object
></chart
></example
><pc
>In this case, the word was <langData
lang="lVernacular"
>ambu</langData
>, but no natural class has the segment <langData
lang="lVernacular"
>b</langData
> in it. So when it tried to find a natural class for <langData
lang="lVernacular"
>b</langData
>, it failed. Notice that it does show what was found. (If the segment is the first item in the word, the found classes will be <object
type="tErrorMessageText"
>''</object
> and the covered graphemes will be <object
type="tErrorMessageText"
>''</object
>.)</pc
><p
><indexedItem
term="iFailureCVSyllables"
></indexedItem
>For the final step, if the sequence of natural classes could not be parsed into syllables per the ordered syllable patterns, then the following message is reported:</p
><example
num="xCVTryAWordSylFailure"
><chart
><object
type="tErrorMessageText"
>Failure: could not parse natural classes into syllables</object
></chart
></example
><pc
>What follows this is an explanatory paragraph as noted above for example <exampleRef
letter="xCVTryAWordachinmeh2"
num="xCVTryAWordachinmeh2"
></exampleRef
> and then the list of syllable patterns tried. In one project, this looked liked what is in example <exampleRef
letter="xCVTryAWordFailedSyl1"
num="xCVTryAWordFailedSyl1"
></exampleRef
> for the word <langData
lang="lVernacular"
>yanjkuik</langData
>.</pc
><example
num="xCVTryAWordFailedSyl1"
><chart
><img
height="200"
src="resources/CVTryAWordFailedSyl1.png"
></img
></chart
></example
><pc
>Notice that none of the patterns are in green. Four are in red and two are in blue. Recall from above that this means that none of the red patterns matched the beginning of the sequence of natural classes (which was <object
type="tGreenText"
>C, V, C, C, K, C</object
>). The two blue ones did match the beginning of the sequence, but did not ultimately lead to a successful parse. Example <exampleRef
letter="xCVTryAWordFailedSyl2"
num="xCVTryAWordFailedSyl2"
></exampleRef
> shows what it looked like when opening the second blue pattern (<object
type="tBlueText"
>C, V, C</object
>).</pc
><example
num="xCVTryAWordFailedSyl2"
><chart
><img
height="200"
src="resources/CVTryAWordFailedSyl2.png"
></img
></chart
></example
><pc
>Notice that all the embedded patterns are in red: none of them matched the beginning of the natural class sequence after removing the initial <object
type="tBlueText"
>C, V, C</object
> part that had matched (i.e., with <object
type="tGreenText"
>C, K, C</object
>).</pc
></section2
><section2
id="sCVPredicitedVsCorrect"
><secTitle
>Predicted vs.​ correct CV words</secTitle
><p
><indexedItem
term="iCVPredictedVsCorrect"
></indexedItem
><indexedItem
term="iCVPredictedSyllabificationCompare"
></indexedItem
>The <object
type="tCVPredictedVsCorrectWords"
></object
> view shows any words which have both a predicted value and a correct value and, in addition, the two values differ. This is intended to give you a way to quickly see how the predictions of the current set of segments, natural classes, and syllable patterns differ from the expected results. In this view, by the way, the predicted and correct words are aligned in pairs with the predicted syllabification immediately above the correct syllabification. This is an attempt to make it easier to see the differences between the two.</p
></section2
></section1
><section1
id="sSonorityHiearchyApproach"
><secTitle
><object
type="tSHApproach"
></object
></secTitle
><p
><indexedItem
term="iSonorityHierarchyApproach"
></indexedItem
>In the <object
type="tSHApproach"
></object
>, you need to define the following items:</p
><ol
><li
>segments (<sectionRef
sec="sSHSegmentInventory"
></sectionRef
>)</li
><li
>a sonority hierarchy via natural classes (<sectionRef
sec="sSHSonorityHierarchy"
></sectionRef
>)</li
><li
>grapheme natural classes (<sectionRef
sec="sSHGraphemeNaturalClasses"
></sectionRef
>)</li
><li
>environments (<sectionRef
sec="sSHEnvironments"
></sectionRef
>)</li
></ol
><p
>After that, you either use a existing word list, import a word list (see <sectionRef
sec="sWords"
></sectionRef
>) or enter a list of words by hand. <indexedItem
term="iParseAllWords"
></indexedItem
>Then you use the <object
type="tMenuItem"
>Parser / Parse all Words </object
> menu item or click on the <img
XeLaTeXSpecial="scaled='500'"
src="resources/SyllabifyWords.png"
></img
> tool bar button. This will apply the algorithm of the <object
type="tSHApproach"
></object
> to all the words. You can then see the results in the <object
type="tSHWords"
></object
> view. See <sectionRef
sec="sSHWords"
textBefore="plural"
></sectionRef
> and <sectionRef
sec="sSHTryAWord"
textBefore="none"
></sectionRef
> for ideas on how to check the results, among other things.</p
><p
>The main “game” to play with the <object
type="tSHApproach"
></object
> in <object
type="tAsheninka"
></object
> is to adjust the segment inventory (including graphemes and their environments), and the sonority hierarchy (i.e., its ordered set of natural classes) so that one gets most, if not all, words to syllabify correctly. Depending on the needs of the language you are modeling, you may find that this algorithm is less than you need as noted in the “Overview” document.</p
><p
>In rough terms, it tries to find all possible sequences of segments in the word. If it can do that, it then seeks to find a sequence of syllables based on the sonority hierarchy, where segments rise in sonority to the peak and then fall in sonority. See appendix <appendixRef
app="aSHAlgorithmInDetail"
></appendixRef
> for details.</p
><p
>We now give more information on the various views available in the user interface for the <object
type="tSHApproach"
></object
>.</p
><section2
id="sSHSegmentInventory"
><secTitle
>SH segment inventory</secTitle
><p
><indexedItem
term="iSHSegments"
></indexedItem
>The <object
type="tSHSegmentInventory"
></object
> view works exactly like the <object
type="tCVSegmentInventory"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sCVSegmentInventory"
></sectionRef
> for details.</p
></section2
><section2
id="sSHSonorityHierarchy"
><secTitle
>Sonority hierarchy</secTitle
><p
><indexedItem
term="iSHSonorityHierarchy"
></indexedItem
>Use the <object
type="tSHSonorityHierarchy"
></object
> view to create an ordered set of natural classes that constitute the sonority hierarchy you wish to use. More sonorous classes are above less sonorous classes.</p
><p
>The <object
type="tField"
>Name</object
> field is for you to define a short name for this natural class. We suggest using something short. The <object
type="tField"
>Description</object
> field is for your use to document anything more specific about this class.</p
><p
>The <object
type="tField"
>Segments</object
> field shows the set of segments this class consists of. It has a chooser button on the far right which looks like <img
XeLaTeXSpecial="scaled='500'"
src="resources/ChooserButton.png"
></img
>. Click on it to bring up a dialog box which lets you select the segments which constitute this class.</p
><p
><object
type="tAsheninka"
></object
> checks to see two things:</p
><ol
><li
>If every segment appears in some class, and</li
><li
>if a given segment has already been used in some other class.</li
></ol
><p
>If either or both of these conditions exist, a box will appear showing which segments and or segment/class combinations are problematic. It is up to you to fix any problem. If a given segment is not in any class, then any word containing that segment will fail to syllabify. If a given segment is in more than one class, the syllabification algorithm will use the topmost class containing that segment.</p
><p
>Finally, the order in which the classes occur is important. The items are in order of sonority: the most sonorous at top and the least sonorous at the bottom. You control the order of the classes by clicking on a class in the middle pane and then using the up and down arrows to change its order. Note that the normal way of sorting by a column via clicking on a column header is disabled for this view.</p
></section2
><section2
id="sSHGraphemeNaturalClasses"
><secTitle
>Grapheme natural classes</secTitle
><p
><indexedItem
term="iSHGraphemes"
></indexedItem
>This works exactly like the <object
type="tGraphemeNaturalClasses"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sGraphemeNaturalClasses"
></sectionRef
> for details.</p
></section2
><section2
id="sSHEnvironments"
><secTitle
>Environments</secTitle
><p
><indexedItem
term="iSHEnvironments"
></indexedItem
>This works exactly like the <object
type="tEnvironments"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sEnvironments"
></sectionRef
> for details.</p
></section2
><section2
id="sSHWords"
><secTitle
>Sonority hierarchy words</secTitle
><p
><indexedItem
term="iSHEnvironments"
></indexedItem
>This works like the <object
type="tCVWords"
></object
> view for the <object
type="tCVPatternApproach"
></object
>, except that the <object
type="tPredictedSyllableBreaks"
></object
> values, the <object
type="tParserResult"
></object
> values, and the <object
type="tParserTreeDiagram"
></object
> are the result of the <object
type="tSHApproach"
></object
> algorithm. In the tree diagram, there is no intervening structure between the syllable and the segment. See <sectionRef
sec="sCVWords"
></sectionRef
> for more on this view.</p
></section2
><section2
id="sSHTryAWord"
><secTitle
>Sonority hierarchy Try a Word</secTitle
><p
><indexedItem
term="iSHTryAWord"
></indexedItem
><indexedItem
term="iTryAWord"
></indexedItem
>There are times when it may be difficult to know just why a given word is not syllabifying correctly. That's where the <object
type="tTryAWord"
></object
> dialog box can be useful. To see it, use the <object
type="tMenuItem"
>Parser / Try a Word</object
> menu item. This brings up a dialog box like the one shown in example <exampleRef
letter="xSHTryAWord"
num="xSHTryAWord"
></exampleRef
>. Unlike most dialog boxes, you can keep the <object
type="tTryAWord"
></object
> dialog box open while still editing other views in the main window. Unfortunately, the minimize button does not currently work so you cannot minimize the dialog, but you can drag it around and resize it. Further, the size and location of the <object
type="tTryAWord"
></object
> dialog box can be set independently for all six approaches; you can have several <object
type="tTryAWord"
></object
> dialog boxes open at the same time if you wish.</p
><example
num="xSHTryAWord"
><chart
><img
src="resources/CVTryAWord1.png"
width="500"
></img
></chart
></example
><p
>You can key a word to try in the text box. By default, <object
type="tAsheninka"
></object
> shows the current word selected in the <object
type="tSHWords"
></object
> view (if you are showing that view), the current word selected in the <object
type="tSHPredictedVsCorrectWords"
></object
> view (if you are showing that view) or the last word you used (or nothing if you've never used <object
type="tTryAWord"
></object
> before and are not showing the <object
type="tSHWords"
></object
> view).</p
><p
>When you either press the <object
type="tKey"
>Enter</object
> key or click on the <object
type="tButton"
>Try it</object
> button, <object
type="tAsheninka"
></object
> will try to parse the word in the text box and report the result in the Results portion of the dialog box.</p
><p
>For the <object
type="tSHApproach"
></object
>, there are at most two steps that are tried:</p
><ol
><li
>Parsing into segments.</li
><li
>Parsing segments into syllables (via their natural classes).</li
></ol
><p
>The results portion always shows the parsing into segments. If this succeeded, then it also shows the parsing of segments into syllables. Successful steps are shown in <object
type="tGreen"
></object
> while unsuccessful ones are shown in <object
type="tRed"
></object
>. An example of a successful parse is shown in example <exampleRef
letter="xSHTryAWordachinmeh1"
num="xSHTryAWordachinmeh1"
></exampleRef
>.</p
><example
num="xSHTryAWordachinmeh1"
><chart
><img
src="resources/SHTryAWord2.png"
width="500"
></img
></chart
></example
><p
><indexedItem
term="iFailureSHSegmenter"
></indexedItem
>The parsing into segments part is exactly the same as it is for the <object
type="tCVPatternApproach"
></object
>, although the tree diagram is simpler.</p
><p
>Scrolling the results window down shows the last part:</p
><example
num="xSHTryAWordachinmeh2"
><chart
><img
src="resources/SHTryAWord3.png"
width="500"
></img
></chart
></example
><pc
>In the last part, it shows the sequence of segment pairs that were found along with their respective natural class and relationship. The <object
type="tBold"
>Relation</object
> column uses mathematical symbols to indicate the relationship as given in example <exampleRef
letter="xSHtryAWordRelation"
num="xSHtryAWordRelation"
></exampleRef
>.</pc
><example
num="xSHtryAWordRelation"
><table
border="1"
><tr
><th
align="center"
>Relation</th
><th
>Meaning</th
></tr
><tr
><td
align="center"
>&lt;</td
><td
>Segment 1 is less sonorous than segment 2.</td
></tr
><tr
><td
align="center"
>=</td
><td
>Segment 1 is equal in sonority to segment 2.</td
></tr
><tr
><td
align="center"
>&gt;</td
><td
>Segment 1 is more sonorous than segment 2.</td
></tr
><tr
><td
align="center"
>!!!</td
><td
>The segment was not in any natural class.</td
></tr
></table
></example
><pc
>The <object
type="tBold"
>Starts Syllable</object
> column shows a syllable symbol (σ) when the algorithm began a new syllable.</pc
><p
>As mentioned above, whenever one of the two steps fails, there is an error message shown for that step (and no following steps will be tried). See <sectionRef
sec="sCVTryAWord"
></sectionRef
> for examples where the segments could not be parsed.</p
><p
><indexedItem
term="iFailureSHNaturalClasser"
></indexedItem
>If a word contains a segment that is not in any natural class, the sonority hierarchy results table will end with a row whose <object
type="tBold"
>Relation</object
> column contains “!!!” in red and one of the offending segments will have “(No Natural Class)” after it as shown in example <exampleRef
letter="xSHTryAWordNCFailure"
num="xSHTryAWordNCFailure"
></exampleRef
>.</p
><example
num="xSHTryAWordNCFailure"
><chart
><img
src="resources/SHTryAWordNCFailure.png"
></img
></chart
></example
><pc
>In this case, the word was <langData
lang="lVernacular"
>ambu</langData
>, but no natural class has the segment <langData
lang="lVernacular"
>b</langData
> in it. So when it tried to find a natural class for <langData
lang="lVernacular"
>b</langData
>, it failed</pc
></section2
><section2
id="sSHPredicitedVsCorrect"
><secTitle
>Predicted vs.​ correct Son. Hier. words</secTitle
><p
><indexedItem
term="iSHPredictedVsCorrect"
></indexedItem
><indexedItem
term="iSHPredictedSyllabificationCompare"
></indexedItem
>The <object
type="tSHPredictedVsCorrectWords"
></object
> view shows any words which have both a predicted value and a correct value and, in addition, the two values differ. This is intended to give you a way to quickly see how the predictions of the current set of segments and sonority hierarchy differ from the expected results. In this view the predicted and correct words are aligned in pairs with the predicted syllabification immediately above the correct syllabification. This is an attempt to make it easier to see the differences between the two.</p
></section2
></section1
><section1
id="sONCApproach"
><secTitle
><object
type="tONCApproach"
></object
></secTitle
><p
><indexedItem
term="iONCApproach"
></indexedItem
>In the <object
type="tONCApproach"
></object
>, you need to define the following items:</p
><ol
><li
>segments (<sectionRef
sec="sONCSegmentInventory"
></sectionRef
>)</li
><li
>a sonority hierarchy via natural classes (<sectionRef
sec="sONCSonorityHierarchy"
></sectionRef
>)</li
><li
>syllabification parameters (<sectionRef
sec="sONCSyllabificationParameters"
></sectionRef
>)</li
><li
>grapheme natural classes (<sectionRef
sec="sONCGraphemeNaturalClasses"
></sectionRef
>)</li
><li
>environments (<sectionRef
sec="sONCEnvironments"
></sectionRef
>)</li
></ol
><p
>If needed to successfully parse your language, you may also need to define these items:</p
><ol
><li
>CV Natural Classes which are used in the next two (section <sectionRef
sec="sONCCVNaturalClasses"
></sectionRef
>)</li
><li
>templates (section <sectionRef
sec="sONCTemplates"
></sectionRef
>)</li
><li
>filters section <sectionRef
sec="sONCFilters"
></sectionRef
>)</li
></ol
><p
>After that, you either use a existing word list, import a word list (see <sectionRef
sec="sWords"
></sectionRef
>) or enter a list of words by hand. <indexedItem
term="iParseAllWords"
></indexedItem
>Then you use the <object
type="tMenuItem"
>Parser / Parse all Words </object
> menu item or click on the <img
XeLaTeXSpecial="scaled='500'"
src="resources/SyllabifyWords.png"
></img
> tool bar button. This will apply the algorithm of the <object
type="tONCApproach"
></object
> to all the words. You can then see the results in the <object
type="tONCWords"
></object
> view. See <sectionRef
sec="sONCWords"
textBefore="plural"
></sectionRef
> and <sectionRef
sec="sONCTryAWord"
textBefore="none"
></sectionRef
> for ideas on how to check the results, among other things.</p
><p
>The main “game” to play with the <object
type="tONCApproach"
></object
> in <object
type="tAsheninka"
></object
> is to adjust the segment inventory (including graphemes and their environments), the sonority hierarchy (i.e., its ordered set of natural classes) and the syllabification parameters so that one gets most, if not all, words to syllabify correctly. You may also need to write templates and/or filters to get some words to parse.</p
><p
>In rough terms, it tries to find all possible sequences of segments in the word. If it can do that, it then seeks to find sequences of onset, nucleus, and coda segments that can be placed in a syllable, modulo the parsing parameters. See appendix <appendixRef
app="aONCAlgorithmInDetail"
></appendixRef
> for details.</p
><p
>We now give more information on the various views available in the user interface for the <object
type="tONCApproach"
></object
>.</p
><section2
id="sONCSegmentInventory"
><secTitle
>ONC segment inventory</secTitle
><p
><indexedItem
term="iONCSegments"
></indexedItem
>The <object
type="tONCSegmentInventory"
></object
> view is similar to the <object
type="tCVSegmentInventory"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sCVSegmentInventory"
></sectionRef
> for details. In addition to what the <object
type="tCVSegmentInventory"
></object
> view has, the <object
type="tONCSegmentInventory"
></object
> view also has three check boxes, one each for the following:</p
><ol
><li
>Can be in onset</li
><li
>Can be in nucleus</li
><li
>Can be in coda</li
></ol
><pc
>Check the boxes for what positions the segment can be in.</pc
></section2
><section2
id="sONCSonorityHierarchy"
><secTitle
>Sonority hierarchy</secTitle
><p
><indexedItem
term="iONCSonorityHierarchy"
></indexedItem
>The <object
type="tONCSonorityHierarchy"
></object
> view works exactly like the <object
type="tSHSonorityHierarchy"
></object
> view does for the <object
type="tSHApproach"
></object
>. See <sectionRef
sec="sSHSonorityHierarchy"
></sectionRef
> for details.</p
></section2
><section2
id="sONCSyllabificationParameters"
><secTitle
>Syllabification parameters</secTitle
><p
><indexedItem
term="iONCSyllabificationParameters"
></indexedItem
><indexedItem
term="iSyllabificationParameters"
></indexedItem
>The <object
type="tSyllabificationParameters"
></object
> view is where you set the parameters to control syllabification for your language. To read more about these parameters, you can click <link
href="Overview.pdf"
>here</link
> or use the <object
type="tMenuItem"
>Help / Introduction to syllabification</object
> menu item.</p
><p
><indexedItem
term="iCodasAllowed"
></indexedItem
>The <object
type="tField"
>Codas allowed</object
> field is a check box. If codas are allowed, check the box. Otherwise, leave it unchecked.</p
><p
><indexedItem
term="iOnsetMaximization"
></indexedItem
>The <object
type="tField"
>Onset maximization</object
> field is a check box. If onsets should be maximized, then check the box. Otherwise, leave it unchecked.</p
><p
><indexedItem
term="iOnsetPrinciple"
></indexedItem
>The <object
type="tField"
>Onset principle</object
> field has three radio buttons. One of them must be set. The three options are:</p
><ol
><li
><indexedItem
term="iAllButFirst"
></indexedItem
>All but the first syllable must have an onset</li
><li
><indexedItem
term="iEverySyllable"
></indexedItem
>Every syllable must have an onset</li
><li
><indexedItem
term="iOnsetsNotRequired"
></indexedItem
>Onsets are not required</li
></ol
></section2
><section2
id="sONCCVNaturalClasses"
><secTitle
>CV natural classes</secTitle
><p
>The <object
type="tCVNaturalClasses"
></object
> view is exactly the same as the <object
type="tCVNaturalClasses"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See section <sectionRef
sec="sCVNaturalClasses"
></sectionRef
> for details.</p
></section2
><section2
id="sONCTemplates"
><secTitle
>ONC templates</secTitle
><p
><indexedItem
term="iONCTemplates"
></indexedItem
>Templates can be used in two situations currently in <object
type="tAsheninka"
></object
> with the <object
type="tONCApproach"
></object
>:</p
><ol
><li
>For a nucleus, it requires the set of slots to be present.</li
><li
>For all others, it provides a way to override <object
type="tSHSonorityHierarchy"
></object
> violations.</li
></ol
><p
>Note that syllable templates are not currently implemented.</p
><p
>When defining a template, you fill in the fields. The “Name” field is for you to remember this template.</p
><p
>Its "Description” field lets you define it more fully, perhaps including some example words as to why you added the template in the first place.</p
><p
>The “Type” field lets you select the constituent structure the template is for.</p
><p
>The “Slots” field is where you define the pattern for when the template will apply. You can use segment names or CV natural class names (see <sectionRef
sec="sONCCVNaturalClasses"
></sectionRef
>) enclosed in square brackets (e.g., "[C]”). If the segment or the natural class can violate the <object
type="tSHSonorityHierarchy"
></object
>, then key an asterisk (*) before the segment name or the opening square bracket. If the item is optional, enclose it within parentheses.</p
><p
>If you have a sequence of two or more items consisting of the same segment or class and at least one of the items is required while the rest are optional, then be sure to make the leftmost one(s) be required. (See the word final example in <exampleRef
letter="xTemplatesEnglish"
num="xTemplatesEnglish"
></exampleRef
> below.)</p
><p
><indexedItem
term="iEnglish"
></indexedItem
>Example <exampleRef
letter="xTemplatesEnglish"
num="xTemplatesEnglish"
></exampleRef
> has some examples from an English project.</p
><example
num="xTemplatesEnglish"
><table
border="1"
><tr
><th
>Type</th
><th
>Slots</th
><th
>Description</th
></tr
><tr
><td
>Onset</td
><td
>*s [VoicelessNonCont] ([SonorantC])</td
><td
>Allow /<langData
lang="lIPA"
>s</langData
>/ in an onset which violates the SSP</td
></tr
><tr
><td
> </td
><td
> </td
><td
> </td
></tr
><tr
><td
>Word final</td
><td
>*[Coronal] (*[Coronal]) (*[Coronal])</td
><td
>Appendix to allow for <langData
lang="lIPA"
>sɪksθs</langData
>, etc.</td
></tr
><tr
><td
> </td
><td
> </td
><td
> </td
></tr
><tr
><td
>Word final</td
><td
>*[VoicelessNonCont] ([Coronal])</td
><td
>Word final appendix for /<langData
lang="lIPA"
>sp</langData
>/ and /<langData
lang="lIPA"
>sk</langData
>/</td
></tr
></table
></example
><p
>Finally, the order in which the templates occur is important. The items are in order of priority: the first to be tried (of a given type) is higher and the last to be tried (of that type) is lower. You control the order of the templates by clicking on a template in the middle pane and then using the up and down arrows to change its order. Note that the normal way of sorting by a column via clicking on a column header is disabled for this view.</p
></section2
><section2
id="sONCFilters"
><secTitle
>ONC filters</secTitle
><p
><indexedItem
term="iONCFilter"
></indexedItem
>Filters can be used in four situations currently in <object
type="tAsheninka"
></object
> with the <object
type="tONCApproach"
></object
>:</p
><ol
><li
>onset,</li
><li
>nucleus,</li
><li
>coda, and</li
><li
>rime.</li
></ol
><p
>Filters come in two varieties: fail and repair. When a filter is matched and is marked as fail, then the syllable parsing stops at that point and seeks other possibilities, if any. When the filter matches and is marked as repair, it will seek to fix up the syllable constituents around it to fix the situation. For example, for English, a word such as <langData
lang="lEnglishExmple"
>Atlantic</langData
> (<langData
lang="lIPA"
>ætlæntɪk</langData
>) will normally syllabify as <langData
lang="lIPA"
>æ.tlæn.tɪk</langData
> but it needs to syllabify as <langData
lang="lIPA"
>æt.læn.tɪk</langData
>. By adding an onset repair filter that matches the <langData
lang="lIPA"
>tl</langData
> sequence, one can obtain the correct result.</p
><p
>When defining a filter, you fill in the fields. The “Name” field is for you to remember this filter.</p
><p
>Its "Description” field lets you define it more fully, perhaps including some example words as to why you added the filter in the first place.</p
><p
>The “Scope” field lets you select the constituent structure the filter has scope over.</p
><p
>The “Action” radio buttons let you specify whether the filter will fail when matched or attempt a repair.</p
><p
>The “Slots” field is where you define the pattern for when the filter will apply. You can use segment names or CV natural class names (see section <sectionRef
sec="sONCCVNaturalClasses"
></sectionRef
>) enclosed in square brackets (e.g., "[C]”). If the segment or the natural class can violate the <object
type="tSHSonorityHierarchy"
></object
>, then key an asterisk (*) before the segment name or the opening square bracket. If the item is optional, enclose it within parentheses. Just like with keying slots in templates, if you have a sequence of two or more items consisting of the same segment or class and at least one of the items is required while the rest are optional, then be sure to make the leftmost one(s) be required. (See the word final example in <exampleRef
letter="xTemplatesEnglish"
num="xTemplatesEnglish"
></exampleRef
> above.)</p
><p
>If it is a repair filter, then key a vertical bar (|) at the point where the repair will occur.</p
><p
>Note that for onset-oriented repair filters, one can also key an underscore character ( _ ) at the point before the first segment or class at the point where the onset begins (i.e., just before the first segment or class in the onset). This enables you to give some context for the preceding syllable.</p
><p
><indexedItem
term="iEnglish"
></indexedItem
>Example <exampleRef
letter="xFiltersEnglish"
num="xFiltersEnglish"
></exampleRef
> has some examples from an English project. They are all repair filters. <indexedItem
term="iQuiegolaniZapotec"
></indexedItem
>Example <exampleRef
letter="xFiltersZPI"
num="xFiltersZPI"
></exampleRef
> has an example from Quiegolani Zapotec which makes use of the context in the preceding syllable ([Obs] is a class of obstruents).</p
><example
num="xFiltersEnglish"
><table
border="1"
><tr
><th
>Type</th
><th
>Slots</th
><th
>Description</th
></tr
><tr
><td
>Onset</td
><td
>[Non-stridentCoronal] | l</td
><td
>Disallow non-strident coronal before labial in an onset. Example: <langData
lang="lIPA"
>ætlæntɪk</langData
> (<langData
lang="lEnglishExmple"
>Atlantic</langData
>) should be <langData
lang="lIPA"
>æt.læn.tɪk</langData
>, not <langData
lang="lIPA"
>æ.tlæn.tɪk</langData
>.</td
></tr
><tr
><td
> </td
><td
> </td
><td
> </td
></tr
><tr
><td
>Onset</td
><td
>[Stop] | [N]</td
><td
>Disallow stop/nasal in a onset. Example: <langData
lang="lIPA"
>æpniə</langData
> (<langData
lang="lEnglishExmple"
>apnea</langData
>) should be <langData
lang="lIPA"
>æp.ni.ə</langData
>, not <langData
lang="lIPA"
>æ.pni.ə</langData
>.</td
></tr
><tr
><td
> </td
><td
> </td
><td
> </td
></tr
><tr
><td
>Onset</td
><td
>[Labial] | [Labial]</td
><td
>Disallow two labials in an onset. Exampleː <langData
lang="lIPA"
>ʃapwoɹn</langData
> (<langData
lang="lEnglishExmple"
>shopworn</langData
>) should be <langData
lang="lIPA"
>ʃap.woɹn</langData
>, not <langData
lang="lIPA"
>ʃa.pwoɹn</langData
>.</td
></tr
></table
></example
><example
num="xFiltersZPI"
><table
border="1"
><tr
><th
>Type</th
><th
>Slots</th
><th
>Description</th
></tr
><tr
><td
>Onset</td
><td
>[V] [Sonorant] _ *[Obs] | ([Sonorant]) *[Obs]</td
><td
>Disallow an obstruent before another obstruent in an onset when the preceding syllable's rime contains a vowel and a sonorant. Example: <langData
lang="lZPI"
>baanske</langData
> (<langData
lang="lEnglishExmple"
>sadly</langData
>) should be <langData
lang="lZPI"
>baans.ke</langData
>, not <langData
lang="lZPI"
>baan.ske</langData
>.</td
></tr
></table
></example
><p
>Finally, the order in which the filters occur is important. The items are in order of priority: the first to be tried (of a given scope) is higher and the last to be tried (of that scope) is lower. You control the order of the filters by clicking on a filter in the middle pane and then using the up and down arrows to change its order. Note that the normal way of sorting by a column via clicking on a column header is disabled for this view.</p
></section2
><section2
id="sONCWords"
><secTitle
>ONC words</secTitle
><p
><indexedItem
term="iONCWords"
></indexedItem
>This works like the <object
type="tCVWords"
></object
> view for the <object
type="tCVPatternApproach"
></object
>, except that the <object
type="tPredictedSyllableBreaks"
></object
> values, the <object
type="tParserResult"
></object
> values, and the <object
type="tParserTreeDiagram"
></object
> are the result of the <object
type="tONCApproach"
></object
> algorithm. If the parse fails and some word structure was built, then this partial word structure is shown by <object
type="tParserTreeDiagram"
></object
>. In the tree diagram, a syllable may have an <object
type="tCategory"
>O</object
> (onset) and a required <object
type="tCategory"
>R</object
> (rime) constituent. A rime has an <object
type="tCategory"
>N</object
> (nucleus) and an optional <object
type="tCategory"
>C</object
> (coda) constituent. See <sectionRef
sec="sCVWords"
></sectionRef
> for more on this view.</p
></section2
><section2
id="sONCPredicitedVsCorrect"
><secTitle
>Predicted vs.​ correct ONC words</secTitle
><p
><indexedItem
term="iONCPredictedVsCorrect"
></indexedItem
><indexedItem
term="iONCPredictedSyllabificationCompare"
></indexedItem
>The <object
type="tONCPredictedVsCorrectWords"
></object
> view shows any words which have both a predicted value and a correct value and, in addition, the two values differ. This is intended to give you a way to quickly see how the results of applying the <object
type="tONCApproach"
></object
> differ from the expected results. In this view the predicted and correct words are aligned in pairs with the predicted syllabification immediately above the correct syllabification. This is an attempt to make it easier to see the differences between the two.</p
></section2
><section2
id="sONCGraphemeNaturalClasses"
><secTitle
>Grapheme natural classes</secTitle
><p
><indexedItem
term="iONCGraphemes"
></indexedItem
>This works exactly like the <object
type="tGraphemeNaturalClasses"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sGraphemeNaturalClasses"
></sectionRef
> for details.</p
></section2
><section2
id="sONCEnvironments"
><secTitle
>Environments</secTitle
><p
><indexedItem
term="iONCEnvironments"
></indexedItem
>This works exactly like the <object
type="tEnvironments"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sEnvironments"
></sectionRef
> for details.</p
></section2
><section2
id="sONCTryAWord"
><secTitle
>ONC Try a Word</secTitle
><p
><indexedItem
term="iONCTryAWord"
></indexedItem
><indexedItem
term="iTryAWord"
></indexedItem
>There are times when it may be difficult to know just why a given word is not syllabifying correctly. That's where the <object
type="tTryAWord"
></object
> dialog box can be useful. To see it, use the <object
type="tMenuItem"
>Parser / Try a Word</object
> menu item. This brings up a dialog box like the one shown in example <exampleRef
letter="xONCTryAWord"
num="xONCTryAWord"
></exampleRef
>. Unlike most dialog boxes, you can keep the <object
type="tTryAWord"
></object
> dialog box open while still editing other views in the main window. Unfortunately, the minimize button does not currently work so you cannot minimize the dialog, but you can drag it around and resize it. Further, the size and location of the <object
type="tTryAWord"
></object
> dialog box can be set independently for all six approaches; you can have several <object
type="tTryAWord"
></object
> dialog boxes open at the same time if you wish.</p
><example
num="xONCTryAWord"
><chart
><img
src="resources/CVTryAWord1.png"
width="500"
></img
></chart
></example
><p
>You can key a word to try in the text box. By default, <object
type="tAsheninka"
></object
> shows the current word selected in the <object
type="tONCWords"
></object
> view (if you are showing that view), the current word selected in the <object
type="tONCPredictedVsCorrectWords"
></object
> view (if you are showing that view) or the last word you used (or nothing if you've never used <object
type="tTryAWord"
></object
> before and are not showing the <object
type="tONCWords"
></object
> view).</p
><p
>When you either press the <object
type="tKey"
>Enter</object
> key or click on the <object
type="tButton"
>Try it</object
> button, <object
type="tAsheninka"
></object
> will try to parse the word in the text box and report the result in the Results portion of the dialog box.</p
><p
>For the <object
type="tONCApproach"
></object
>, there are at most two steps that are tried:</p
><ol
><li
>Parsing into segments.</li
><li
>Parsing segments into syllables (via the onset-nucleus-coda algorithm; see appendix <appendixRef
app="aONCAlgorithmInDetail"
></appendixRef
> below).</li
></ol
><p
>The results portion always shows the parsing into segments. If this succeeded, then it also shows the parsing of segments into syllables. Successful steps are shown in <object
type="tGreen"
></object
> while unsuccessful ones are shown in <object
type="tRed"
></object
>. An example of a successful parse is shown in example <exampleRef
letter="xONCTryAWordahwiyak1"
num="xONCTryAWordahwiyak1"
></exampleRef
>.</p
><example
num="xONCTryAWordahwiyak1"
><chart
><img
src="resources/ONCTryAWord2.png"
width="500"
></img
></chart
></example
><p
><indexedItem
term="iFailureONCSegmenter"
></indexedItem
>The parsing into segments part is exactly the same as it is for the <object
type="tCVPatternApproach"
></object
>. If any constituent structure was built during the parse, the tree diagram is also shown. The <object
type="tCategory"
>W</object
> constituent is the word and the <object
type="tCategory"
>σ</object
> constituent indicates a syllable. A syllable may have an <object
type="tCategory"
>O</object
> (onset) and a required <object
type="tCategory"
>R</object
> (rime) constituent. A rime has an <object
type="tCategory"
>N</object
> (nucleus) and an optional <object
type="tCategory"
>C</object
> (coda) constituent. Below these are the segment and then its grapheme. If the parse succeeded, then the segments and their graphemes are shown in green. If the parse failed but some of the tree was built, then the segments and their graphemes are shown in red.</p
><p
>Scrolling the results window down shows the last part:</p
><example
num="xONCTryAWordahwiyak2"
><chart
><img
src="resources/ONCTryAWord3.png"
width="500"
></img
></chart
></example
><pc
>In the last part, it shows the sequence of segment pairs that were found along with their respective natural class and relationship. The <object
type="tBold"
>Relation</object
> column uses mathematical symbols to indicate the relationship as given in example <exampleRef
letter="xONCTryAWordRelation"
num="xONCTryAWordRelation"
></exampleRef
>.</pc
><example
num="xONCTryAWordRelation"
><table
border="1"
><tr
><th
align="center"
>Relation</th
><th
>Meaning</th
></tr
><tr
><td
align="center"
>&lt;</td
><td
>Segment 1 is less sonorous than segment 2.</td
></tr
><tr
><td
align="center"
>=</td
><td
>Segment 1 is equal in sonority to segment 2.</td
></tr
><tr
><td
align="center"
>&gt;</td
><td
>Segment 1 is more sonorous than segment 2.</td
></tr
><tr
><td
align="center"
>!!!</td
><td
>The segment was not in any natural class.</td
></tr
></table
></example
><pc
>The <object
type="tBold"
>Type</object
> column shows the type (or state) the parser is using.</pc
><pc
>The <object
type="tBold"
>Status</object
> column shows what the algorithm did at that part of the processing.</pc
><p
>As mentioned above, whenever one of the two steps fails, there is an error message shown for that step. Depending on the error and the state of the parser at the time, more steps may or may not be tried. See <sectionRef
sec="sCVTryAWord"
></sectionRef
> for examples where the segments could not be parsed.</p
><p
><indexedItem
term="iFailureONCNaturalClasser"
></indexedItem
>If a word contains a segment that is not in any natural class, the onset-nucleus-coda results table will end with a row whose <object
type="tBold"
>Relation</object
> column contains “!!!” in red and one of the offending segments will have “(No Natural Class)” after it as shown in example <exampleRef
letter="xONCTryAWordNCFailure"
num="xONCTryAWordNCFailure"
></exampleRef
>.</p
><example
num="xONCTryAWordNCFailure"
><chart
><img
src="resources/ONCTryAWordNCFailure.png"
width="500"
></img
></chart
></example
><pc
>In this case, the word was <langData
lang="lVernacular"
>tun</langData
>, but no natural class has the segment <langData
lang="lVernacular"
>u</langData
> in it. So when it tried to find a natural class for <langData
lang="lVernacular"
>u</langData
>, it failed</pc
></section2
></section1
><section1
id="sMoraicApproach"
><secTitle
><object
type="tMoraicApproach"
></object
></secTitle
><p
><indexedItem
term="iMoraicApproach"
></indexedItem
>The <object
type="tMoraicApproach"
></object
>, in many ways, is similar to the <object
type="tONCApproach"
></object
>. Like with the <object
type="tONCApproach"
></object
>, you need to define the following items:</p
><ol
><li
>segments (<sectionRef
sec="sMoraicSegmentInventory"
></sectionRef
>)</li
><li
>a sonority hierarchy via natural classes (<sectionRef
sec="sMoraicSonorityHierarchy"
></sectionRef
>)</li
><li
>syllabification parameters (<sectionRef
sec="sMoraicSyllabificationParameters"
></sectionRef
>)</li
><li
>grapheme natural classes (<sectionRef
sec="sMoraicGraphemeNaturalClasses"
></sectionRef
>)</li
><li
>environments (<sectionRef
sec="sMoraicEnvironments"
></sectionRef
>)</li
></ol
><p
>If needed to successfully parse your language, you may also need to define these items:</p
><ol
><li
>CV Natural Classes which are used in the next two (<sectionRef
sec="sMoraicCVNaturalClasses"
></sectionRef
>)</li
><li
>templates (<sectionRef
sec="sMoraicTemplates"
></sectionRef
>)</li
><li
>filters <sectionRef
sec="sMoraicFilters"
></sectionRef
>)</li
></ol
><p
>After that, you either use a existing word list, import a word list (see <sectionRef
sec="sWords"
></sectionRef
>) or enter a list of words by hand. <indexedItem
term="iParseAllWords"
></indexedItem
>Then you use the <object
type="tMenuItem"
>Parser / Parse all Words </object
> menu item or click on the <img
XeLaTeXSpecial="scaled='500'"
src="resources/SyllabifyWords.png"
></img
> tool bar button. This will apply the algorithm of the <object
type="tMoraicApproach"
></object
> to all the words. You can then see the results in the <object
type="tMoraicWords"
></object
> view. See <sectionRef
sec="sMoraicWords"
textBefore="plural"
></sectionRef
> and <sectionRef
sec="sMoraicTryAWord"
textBefore="none"
></sectionRef
> for ideas on how to check the results, among other things.</p
><p
>The main “game” to play with the <object
type="tMoraicApproach"
></object
> in <object
type="tAsheninka"
></object
> is to adjust the segment inventory (including graphemes and their environments), the sonority hierarchy (i.e., its ordered set of natural classes) and the syllabification parameters so that one gets most, if not all, words to syllabify correctly. You may also need to write templates and/or filters to get some words to parse.</p
><p
>In rough terms, it tries to find all possible sequences of segments in the word. If it can do that, it then seeks to find sequences of segments that can be placed in a syllable with a mora-bearing segment at the “heart,” modulo the parsing parameters. See appendix <appendixRef
app="aMoraicAlgorithmInDetail"
></appendixRef
> for details.</p
><p
>We now give more information on the various views available in the user interface for the <object
type="tMoraicApproach"
></object
>.</p
><section2
id="sMoraicSegmentInventory"
><secTitle
>Moraic segment inventory</secTitle
><p
><indexedItem
term="iMoraicSegments"
></indexedItem
>The <object
type="tMoraicSegmentInventory"
></object
> view is similar to the <object
type="tCVSegmentInventory"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sCVSegmentInventory"
></sectionRef
> for details. In addition to what the <object
type="tCVSegmentInventory"
></object
> view has, the <object
type="tMoraicSegmentInventory"
></object
> view also has a place to indicate how many moras the segment bears. Typically, consonants bear zero moras and vowels bear one or two.</p
></section2
><section2
id="sMoraicSonorityHierarchy"
><secTitle
>Sonority hierarchy</secTitle
><p
><indexedItem
term="iMoraicSonorityHierarchy"
></indexedItem
>The <object
type="tMoraicSonorityHierarchy"
></object
> view works exactly like the <object
type="tSHSonorityHierarchy"
></object
> view does for the <object
type="tSHApproach"
></object
>. See <sectionRef
sec="sSHSonorityHierarchy"
></sectionRef
> for details.</p
></section2
><section2
id="sMoraicSyllabificationParameters"
><secTitle
>Syllabification parameters</secTitle
><p
><indexedItem
term="iMoraicSyllabificationParameters"
></indexedItem
><indexedItem
term="iSyllabificationParameters"
></indexedItem
>The <object
type="tSyllabificationParameters"
></object
> view is where you set the parameters to control syllabification for your language. To read more about these parameters, you can click <link
href="Overview.pdf"
>here</link
> or use the <object
type="tMenuItem"
>Help / Introduction to syllabification</object
> menu item. Like the <object
type="tONCApproach"
></object
>, the <object
type="tMoraicApproach"
></object
> has the following three parameters:</p
><p
><indexedItem
term="iCodasAllowed"
></indexedItem
>The <object
type="tField"
>Codas allowed</object
> field is a check box. If codas are allowed, check the box. Otherwise, leave it unchecked.</p
><p
><indexedItem
term="iOnsetMaximization"
></indexedItem
>The <object
type="tField"
>Onset maximization</object
> field is a check box. If onsets should be maximized, then check the box. Otherwise, leave it unchecked.</p
><p
><indexedItem
term="iOnsetPrinciple"
></indexedItem
>The <object
type="tField"
>Onset principle</object
> field has three radio buttons. One of them must be set. The three options are:</p
><ol
><li
><indexedItem
term="iAllButFirst"
></indexedItem
>All but the first syllable must have an onset</li
><li
><indexedItem
term="iEverySyllable"
></indexedItem
>Every syllable must have an onset</li
><li
><indexedItem
term="iOnsetsNotRequired"
></indexedItem
>Onsets are not required</li
></ol
><p
>In addition, the <object
type="tMoraicApproach"
></object
> also has two other parameters:</p
><p
><indexedItem
term="iMaxMoras"
></indexedItem
>The <object
type="tField"
>Maximum moras per syllable</object
> field indicates the maximum number of moras a syllable in this language may have. Typically, this is one or two.</p
><p
><indexedItem
term="iUseWeightByPosition"
></indexedItem
>The <object
type="tField"
>Use weight by position</object
> field is a check box. If the language uses weight by position, check the box. Otherwise, leave it unchecked.</p
></section2
><section2
id="sMoraicCVNaturalClasses"
><secTitle
>CV natural classes</secTitle
><p
>The <object
type="tCVNaturalClasses"
></object
> view is exactly the same as the <object
type="tCVNaturalClasses"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See section <sectionRef
sec="sCVNaturalClasses"
></sectionRef
> for details.</p
></section2
><section2
id="sMoraicTemplates"
><secTitle
>Moraic templates</secTitle
><p
><indexedItem
term="iMoraicTemplates"
></indexedItem
>Templates can be used in two situations currently in <object
type="tAsheninka"
></object
> for the <object
type="tMoraicApproach"
></object
>:</p
><ol
><li
>For a syllable, it provides the pattern of optional and required slots that must be present for a well-formed syllable.</li
><li
>For onsets and word-initial and word-final, it provides a way to override <object
type="tSHSonorityHierarchy"
></object
> violations.</li
></ol
><p
>Note that coda, nucleus and rime templates are not implemented for the <object
type="tMoraicApproach"
></object
> because this approach does not model these constituents.</p
><p
>See <sectionRef
sec="sONCTemplates"
></sectionRef
> for how to define a template.</p
></section2
><section2
id="sMoraicFilters"
><secTitle
>Moraic filters</secTitle
><p
><indexedItem
term="iMoraicFilter"
></indexedItem
>Filters can be used for onsets in <object
type="tAsheninka"
></object
> with the <object
type="tMoraicApproach"
></object
>. While other filters are shown, only onset filters are used. See <sectionRef
sec="sONCFilters"
></sectionRef
> for more on using filters.</p
></section2
><section2
id="sMoraicWords"
><secTitle
>Moraic words</secTitle
><p
><indexedItem
term="iMoraicWords"
></indexedItem
>This works like the <object
type="tCVWords"
></object
> view for the <object
type="tCVPatternApproach"
></object
>, except that the <object
type="tPredictedSyllableBreaks"
></object
> values, the <object
type="tParserResult"
></object
> values, and the <object
type="tParserTreeDiagram"
></object
> are the result of the <object
type="tMoraicApproach"
></object
> algorithm. If the parse fails and some word structure was built, then this partial word structure is shown by <object
type="tParserTreeDiagram"
></object
>. In the tree diagram, a syllable will have any onset consonants connected directly to the syllable node and any mora-bearing segments underneath a Greek mu (<object
type="tMora"
></object
>). See <sectionRef
sec="sCVWords"
></sectionRef
> for more on this view.</p
></section2
><section2
id="sMoraicPredicitedVsCorrect"
><secTitle
>Predicted vs.​ correct Moraic words</secTitle
><p
><indexedItem
term="iMoraicPredictedVsCorrect"
></indexedItem
><indexedItem
term="iMoraicPredictedSyllabificationCompare"
></indexedItem
>The <object
type="tMoraicPredictedVsCorrectWords"
></object
> view shows any words which have both a predicted value and a correct value and, in addition, the two values differ. This is intended to give you a way to quickly see how the results of applying the <object
type="tMoraicApproach"
></object
> differ from the expected results. In this view the predicted and correct words are aligned in pairs with the predicted syllabification immediately above the correct syllabification. This is an attempt to make it easier to see the differences between the two.</p
></section2
><section2
id="sMoraicGraphemeNaturalClasses"
><secTitle
>Grapheme natural classes</secTitle
><p
><indexedItem
term="iMoraicGraphemes"
></indexedItem
>This works exactly like the <object
type="tGraphemeNaturalClasses"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sGraphemeNaturalClasses"
></sectionRef
> for details.</p
></section2
><section2
id="sMoraicEnvironments"
><secTitle
>Environments</secTitle
><p
><indexedItem
term="iMoraicEnvironments"
></indexedItem
>This works exactly like the <object
type="tEnvironments"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sEnvironments"
></sectionRef
> for details.</p
></section2
><section2
id="sMoraicTryAWord"
><secTitle
>Moraic Try a Word</secTitle
><p
><indexedItem
term="iMoraicTryAWord"
></indexedItem
><indexedItem
term="iTryAWord"
></indexedItem
>There are times when it may be difficult to know just why a given word is not syllabifying correctly. That's where the <object
type="tTryAWord"
></object
> dialog box can be useful. To see it, use the <object
type="tMenuItem"
>Parser / Try a Word</object
> menu item. This brings up a dialog box like the one shown in example <exampleRef
letter="xMoraicTryAWord"
num="xMoraicTryAWord"
></exampleRef
>. Unlike most dialog boxes, you can keep the <object
type="tTryAWord"
></object
> dialog box open while still editing other views in the main window. Unfortunately, the minimize button does not currently work so you cannot minimize the dialog, but you can drag it around and resize it. Further, the size and location of the <object
type="tTryAWord"
></object
> dialog box can be set independently for all six approaches; you can have several <object
type="tTryAWord"
></object
> dialog boxes open at the same time if you wish.</p
><example
num="xMoraicTryAWord"
><chart
><img
src="resources/CVTryAWord1.png"
width="500"
></img
></chart
></example
><p
>You can key a word to try in the text box. By default, <object
type="tAsheninka"
></object
> shows the current word selected in the <object
type="tMoraicWords"
></object
> view (if you are showing that view), the current word selected in the <object
type="tMoraicPredictedVsCorrectWords"
></object
> view (if you are showing that view) or the last word you used (or nothing if you've never used <object
type="tTryAWord"
></object
> before and are not showing the <object
type="tMoraicWords"
></object
> view).</p
><p
>When you either press the <object
type="tKey"
>Enter</object
> key or click on the <object
type="tButton"
>Try it</object
> button, <object
type="tAsheninka"
></object
> will try to parse the word in the text box and report the result in the Results portion of the dialog box.</p
><p
>For the <object
type="tMoraicApproach"
></object
>, there are at most two steps that are tried:</p
><ol
><li
>Parsing into segments.</li
><li
>Parsing segments into syllables (via the moraic algorithm; see appendix <appendixRef
app="aMoraicAlgorithmInDetail"
></appendixRef
> below).</li
></ol
><p
>The results portion always shows the parsing into segments. If this succeeded, then it also shows the parsing of segments into syllables. Successful steps are shown in <object
type="tGreen"
></object
> while unsuccessful ones are shown in <object
type="tRed"
></object
>. An example of a successful parse is shown in example <exampleRef
letter="xMoraicTryAWordahwiyak1"
num="xMoraicTryAWordahwiyak1"
></exampleRef
>.</p
><example
num="xMoraicTryAWordahwiyak1"
><chart
><img
src="resources/MoraicTryAWord2.png"
width="500"
></img
></chart
></example
><p
><indexedItem
term="iFailureMoraicSegmenter"
></indexedItem
>The parsing into segments part is exactly the same as it is for the <object
type="tCVPatternApproach"
></object
>. If any constituent structure was built during the parse, the tree diagram is also shown. The <object
type="tCategory"
>W</object
> constituent is the word and the <object
type="tCategory"
>σ</object
> constituent indicates a syllable. A syllable will have a <object
type="tCategory"
><object
type="tMora"
></object
></object
> constituent. Onset segments attach to an <object
type="tCategory"
>O</object
> category and other segments attach to a <object
type="tCategory"
><object
type="tMora"
></object
></object
> constituent. Below these are the segment and then its grapheme. If the parse succeeded, then the segments and their graphemes are shown in green. If the parse failed but some of the tree was built, then the segments and their graphemes are shown in red.</p
><p
>Scrolling the results window down shows the last part:</p
><example
num="xMoraicTryAWordahwiyak2"
><chart
><img
src="resources/MoraicTryAWord3.png"
width="500"
></img
></chart
></example
><pc
>In the last part, it shows the sequence of segment pairs that were found along with their respective natural class and relationship. The <object
type="tBold"
>Relation</object
> column uses mathematical symbols to indicate the relationship as given in example <exampleRef
letter="xMoraicTryAWordRelation"
num="xMoraicTryAWordRelation"
></exampleRef
>.</pc
><example
num="xMoraicTryAWordRelation"
><table
border="1"
><tr
><th
align="center"
>Relation</th
><th
>Meaning</th
></tr
><tr
><td
align="center"
>&lt;</td
><td
>Segment 1 is less sonorous than segment 2.</td
></tr
><tr
><td
align="center"
>=</td
><td
>Segment 1 is equal in sonority to segment 2.</td
></tr
><tr
><td
align="center"
>&gt;</td
><td
>Segment 1 is more sonorous than segment 2.</td
></tr
><tr
><td
align="center"
>!!!</td
><td
>The segment was not in any natural class.</td
></tr
></table
></example
><pc
>The <object
type="tBold"
>Status</object
> column shows what the algorithm did at that part of the processing. Note that if there is a syllable template and especially if that template includes one or more coda slots, then it is possible that the message will show more segments matching the syllable template than will actually end up being in the syllable.</pc
><p
>As mentioned above, whenever one of the two steps fails, there is an error message shown for that step. Depending on the error and the state of the parser at the time, more steps may or may not be tried. See <sectionRef
sec="sCVTryAWord"
></sectionRef
> for examples where the segments could not be parsed.</p
><p
><indexedItem
term="iFailureMoraicNaturalClasser"
></indexedItem
>If a word contains a segment that is not in any natural class, the moraic results table will end with a row whose <object
type="tBold"
>Relation</object
> column contains “!!!” in red and one of the offending segments will have “(No Natural Class)” after it as shown in example <exampleRef
letter="xMoraicTryAWordNCFailure"
num="xMoraicTryAWordNCFailure"
></exampleRef
>.</p
><example
num="xMoraicTryAWordNCFailure"
><chart
><img
src="resources/MoraicTryAWordNCFailure.png"
width="500"
></img
></chart
></example
><pc
>In this case, the word was <langData
lang="lVernacular"
>abay</langData
>, but no natural class has the segment <langData
lang="lVernacular"
>b</langData
> in it. So when it tried to find a natural class for <langData
lang="lVernacular"
>b</langData
>, it failed</pc
></section2
></section1
><section1
id="sNuclearProjectionApproach"
><secTitle
><object
type="tNPApproach"
></object
></secTitle
><p
><indexedItem
term="iNPApproach"
></indexedItem
>For the <object
type="tNPApproach"
></object
>, you need to define the following items:</p
><ol
><li
>segments (<sectionRef
sec="sNPSegmentInventory"
></sectionRef
>)</li
><li
>a sonority hierarchy via natural classes (<sectionRef
sec="sNPSonorityHierarchy"
></sectionRef
>)</li
><li
>syllabification parameters (<sectionRef
sec="sNPSyllabificationParameters"
></sectionRef
>)</li
><li
>CV Natural Classes <sectionRef
sec="sNPCVNaturalClasses"
></sectionRef
>)</li
><li
><object
type="tNPRules"
></object
> (<sectionRef
sec="sNPRules"
></sectionRef
>)</li
><li
>grapheme natural classes (<sectionRef
sec="sNPGraphemeNaturalClasses"
></sectionRef
>)</li
><li
>environments (<sectionRef
sec="sNPEnvironments"
></sectionRef
>)</li
></ol
><p
>If needed to successfully parse your language, you may also need to define <object
type="tNPFilters"
></object
> <sectionRef
sec="sNPFilters"
></sectionRef
>).</p
><p
>After that, you either use a existing word list, import a word list (see <sectionRef
sec="sWords"
></sectionRef
>) or enter a list of words by hand. <indexedItem
term="iParseAllWords"
></indexedItem
>Then you use the <object
type="tMenuItem"
>Parser / Parse all Words </object
> menu item or click on the <img
XeLaTeXSpecial="scaled='500'"
src="resources/SyllabifyWords.png"
></img
> tool bar button. This will apply the algorithm of the <object
type="tNPApproach"
></object
> to all the words. You can then see the results in the <object
type="tNPWords"
></object
> view. See <sectionRef
sec="sNPWords"
textBefore="plural"
></sectionRef
> and <sectionRef
sec="sNPTryAWord"
textBefore="none"
></sectionRef
> for ideas on how to check the results, among other things.</p
><p
>The main “game” to play with the <object
type="tNPApproach"
></object
> in <object
type="tAsheninka"
></object
> is to adjust the segment inventory (including graphemes and their environments), the sonority hierarchy (i.e., its ordered set of natural classes), the syllabification parameters, and the <object
type="tNPRules"
></object
> so that one gets most, if not all, words to syllabify correctly. You may also need to write <object
type="tNPFilters"
></object
> to get some words to parse.</p
><p
>In rough terms, it tries to find all possible sequences of segments in the word. If it can do that, it then seeks to apply each rule in turn. If every segment in the word is in a syllable, then it considers the parse a success. See appendix <appendixRef
app="aNPAlgorithm"
></appendixRef
> for details.</p
><p
>We now give more information on the various views available in the user interface for the <object
type="tNPApproach"
></object
>.</p
><section2
id="sNPSegmentInventory"
><secTitle
>NP segment inventory</secTitle
><p
><indexedItem
term="iNPSegments"
></indexedItem
>The <object
type="tNPSegmentInventory"
></object
> view works exactly like the <object
type="tCVSegmentInventory"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sCVSegmentInventory"
></sectionRef
> for details.</p
></section2
><section2
id="sNPSonorityHierarchy"
><secTitle
>Sonority hierarchy</secTitle
><p
><indexedItem
term="iNPSonorityHierarchy"
></indexedItem
>The <object
type="tNPSonorityHierarchy"
></object
> view works exactly like the <object
type="tSHSonorityHierarchy"
></object
> view does for the <object
type="tSHApproach"
></object
>. See <sectionRef
sec="sSHSonorityHierarchy"
></sectionRef
> for details.</p
></section2
><section2
id="sNPSyllabificationParameters"
><secTitle
>Syllabification parameters</secTitle
><p
><indexedItem
term="iNPSyllabificationParameters"
></indexedItem
><indexedItem
term="iSyllabificationParameters"
></indexedItem
>The <object
type="tSyllabificationParameters"
></object
> view is where you set the parameters to control syllabification for your language. To read more about these parameters, you can click <link
href="Overview.pdf"
>here</link
> or use the <object
type="tMenuItem"
>Help / Introduction to syllabification</object
> menu item. The <object
type="tNPApproach"
></object
> has only one parameter:</p
><p
><indexedItem
term="iOnsetPrinciple"
></indexedItem
>The <object
type="tField"
>Onset principle</object
> field has three radio buttons. One of them must be set. The three options are:</p
><ol
><li
><indexedItem
term="iAllButFirst"
></indexedItem
>All but the first syllable must have an onset</li
><li
><indexedItem
term="iEverySyllable"
></indexedItem
>Every syllable must have an onset</li
><li
><indexedItem
term="iOnsetsNotRequired"
></indexedItem
>Onsets are not required</li
></ol
><p
>The other two parameters are controlled by the <object
type="tNPRules"
></object
>:</p
><ul
><li
><indexedItem
term="iCodasAllowed"
></indexedItem
>Whether codas are allowed or not is controlled by having coda-oriented rules or not having them.</li
><li
><indexedItem
term="iOnsetMaximization"
></indexedItem
>Onset maximization is controlled by ordering onset-oriented rules before any coda rules.</li
></ul
></section2
><section2
id="sNPCVNaturalClasses"
><secTitle
>CV natural classes</secTitle
><p
>The <object
type="tCVNaturalClasses"
></object
> view is exactly the same as the <object
type="tCVNaturalClasses"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See section <sectionRef
sec="sCVNaturalClasses"
></sectionRef
> for details.</p
></section2
><section2
id="sNPRules"
><secTitle
>NP rules</secTitle
><p
><indexedItem
term="iNPRules"
></indexedItem
><object
type="tNPRules"
></object
> drive the syllabification process in the <object
type="tNPApproach"
></object
>. Typically, at least two to five rules need to be defined. The first one must always be one that builds a nucleus and all the needed structure and is usually built on vowels. The other rules add other segments to this.</p
><p
>When defining a <object
type="tNPRule"
></object
>, you fill in the fields. The “Name” field is for you to remember this rule.</p
><p
>Its "Description” field lets you define it more fully, perhaps including some example words as to why you added the rule if it is not one of the standard rules.</p
><p
>The “Affected” field lets you select the segment or natural class that the rule applies to.</p
><p
>The “Context” field lets you select the segment or natural class that must occur before or after the affected item.</p
><p
>The “Action” drop-down chooser lets you select the kind of action the rule has. There are five possible values as shown in example <exampleRef
letter="xRuleActions"
num="xRuleActions"
></exampleRef
>.</p
><example
num="xRuleActions"
><table
border="1"
><tr
><th
>Action</th
><th
>Description</th
></tr
><tr
><td
><object
type="tNPRuleActionAttach"
></object
></td
><td
>Attach the affected segment at the node level of the rule.</td
></tr
><tr
><td
><object
type="tNPRuleActionAugment"
></object
></td
><td
>Augment the affected segment at the node level of the rule.</td
></tr
><tr
><td
><object
type="tNPRuleActionBuild"
></object
></td
><td
>Build the initial nodes. The affected segment will be at the <object
type="tNPRuleLevelN"
></object
> which will be in an <object
type="tNPRuleLevelNBar"
></object
> node which will be in an <object
type="tNPRuleLevelNDoubleBar"
></object
> node which is the first item in a syllable.</td
></tr
><tr
><td
><object
type="tNPRuleActionLeftAdjoin"
></object
></td
><td
>Adjoin the affected segment to the left of the context segment at the indicated node level.</td
></tr
><tr
><td
><object
type="tNPRuleActionRightAdjoin"
></object
></td
><td
>Adjoin the affected segment to the right of the context segment at the indicated node level.</td
></tr
></table
></example
><p
>The “Level” drop-down chooser lets you select the rule node level of the rule. There are four possible values as shown in example <exampleRef
letter="xRuleLevels"
num="xRuleLevels"
></exampleRef
>.</p
><example
num="xRuleLevels"
><table
border="1"
><tr
><th
>Level</th
><th
>Description</th
></tr
><tr
><td
><object
type="tNPRuleLevelAll"
></object
></td
><td
>This indicates the rule will build all the levels.</td
></tr
><tr
><td
><object
type="tNPRuleLevelN"
></object
></td
><td
>This is the nucleus level.</td
></tr
><tr
><td
><object
type="tNPRuleLevelNBar"
></object
></td
><td
>This is the rime level.</td
></tr
><tr
><td
><object
type="tNPRuleLevelNDoubleBar"
></object
></td
><td
>This is the top level to which onsets are attached.</td
></tr
></table
></example
><p
>The “Obeys SSP” check box indicates whether or not the affected item and the context item must obey the Sonority Sequencing Principle.</p
><p
>Example <exampleRef
letter="xStandardRules"
num="xStandardRules"
></exampleRef
> below lists the standard five rules. A dashed line indicates the item that being added.</p
><example
num="xStandardRules"
><table
border="1"
><tr
><th
width="1.35in"
>Rule</th
><th
width=".75in"
>Affected</th
><th
width=".6in"
>Context</th
><th
width=".75in"
>Action</th
><th
width=".45in"
>Level</th
><th
width=".7in"
>Diagram</th
></tr
><tr
><td
>Nucleus</td
><td
>[V]</td
><td
> </td
><td
><object
type="tNPRuleActionBuild"
></object
></td
><td
><object
type="tNPRuleLevelAll"
></object
></td
><td
><img
XeLaTeXSpecial="scaled='1000' vertical-adjustment='-6pt' "
src="LingTreeDiagrams/NPNucleusRule.svg"
></img
></td
></tr
><tr
><td
>Onset</td
><td
>[C]</td
><td
>[V]</td
><td
><object
type="tNPRuleActionAttach"
></object
></td
><td
><object
type="tNPRuleLevelNDoubleBar"
></object
></td
><td
><img
XeLaTeXSpecial="scaled='1000' vertical-adjustment='-6pt' "
src="LingTreeDiagrams/NPOnsetRule.svg"
></img
></td
></tr
><tr
><td
>Coda</td
><td
>[C]</td
><td
>[V]</td
><td
><object
type="tNPRuleActionAttach"
></object
></td
><td
><object
type="tNPRuleLevelNBar"
></object
></td
><td
><img
XeLaTeXSpecial="scaled='1000' vertical-adjustment='-6pt' "
src="LingTreeDiagrams/NPCodaRule.svg"
></img
></td
></tr
><tr
><td
>Augmented onsets</td
><td
>[C]</td
><td
>[C]</td
><td
><object
type="tNPRuleActionAugment"
></object
></td
><td
><object
type="tNPRuleLevelNDoubleBar"
></object
></td
><td
><img
XeLaTeXSpecial="scaled='1000' vertical-adjustment='-6pt' "
src="LingTreeDiagrams/NPOnsetAugmentRule.svg"
></img
></td
></tr
><tr
><td
>Augmented codas</td
><td
>[C]</td
><td
>[C]</td
><td
><object
type="tNPRuleActionAugment"
></object
></td
><td
><object
type="tNPRuleLevelNBar"
></object
></td
><td
><img
XeLaTeXSpecial="scaled='1000' vertical-adjustment='-6pt' "
src="LingTreeDiagrams/NPCodaAugmentRule.svg"
></img
></td
></tr
></table
></example
><pc
>Notice that the level determines whether the affected segment is attached before (as an onset) or after (as a coda). That is, an <object
type="tNPRuleLevelNDoubleBar"
></object
> level means the affected item is attached before. An <object
type="tNPRuleLevelNBar"
></object
> or <object
type="tNPRuleLevelN"
></object
> level means the affected item is attached after.</pc
><p
><indexedItem
term="iCodasAllowed"
></indexedItem
>If a language does not have any codas, then you can either de-activate any coda-oriented rules or you can remove them.</p
><p
><indexedItem
term="iOnsetMaximization"
></indexedItem
>If a language uses onset maximization, then order the rules so that any onset-oriented rules occur before any coda rules.</p
><p
><object
type="tAsheninka"
></object
> only allows certain combinations of affected, context, action and level. Any other combinations will result in an error message stating what the allowed possibilities are. Some of these are summarized here:</p
><ul
><li
>The first active rule must use a <object
type="tNPRuleActionBuild"
></object
> action.</li
><li
>Only the <object
type="tNPRuleActionBuild"
></object
> action can use the <object
type="tNPRuleLevelAll"
></object
> level.</li
><li
>A context item is required for all but a <object
type="tNPRuleActionBuild"
></object
> action and a <object
type="tNPRuleActionBuild"
></object
> action must not have a context item.</li
></ul
><p
>Any adjunction rules will add the affected segment to the left (before) or to the right (after) depending on the action chosen.</p
><p
><indexedItem
term="iEnglish"
></indexedItem
>Example <exampleRef
letter="xAdjunctionRulesEnglish"
num="xAdjunctionRulesEnglish"
></exampleRef
> has a <object
type="tNPRuleActionRightAdjoin"
></object
> example from an English project. It is for the case of words like <langData
lang="lIPA"
>sɪksθ</langData
> (<langData
lang="lEnglishExmple"
>sixth</langData
>) and <langData
lang="lIPA"
>sɪksθs</langData
> (<langData
lang="lEnglishExmple"
>sixths</langData
>).</p
><example
num="xAdjunctionRulesEnglish"
><table
border="1"
><tr
><th
width="1in"
>Rule</th
><th
width=".75in"
>Affected</th
><th
width=".6in"
>Context</th
><th
width=".75in"
>Action</th
><th
width=".45in"
>Level</th
><th
width="1.05in"
>Diagram</th
></tr
><tr
><td
>Word final adjoin</td
><td
>[Coronal]</td
><td
>[C]</td
><td
><object
type="tNPRuleActionRightAdjoin"
></object
></td
><td
><object
type="tNPRuleLevelNDoubleBar"
></object
></td
><td
><img
XeLaTeXSpecial="scaled='1000' vertical-adjustment='-6pt' "
src="LingTreeDiagrams/NPWordFinalAdjoinRule.svg"
></img
></td
></tr
></table
></example
><pc
>In this case, the SSP is not obeyed, which is indicated by the asterisk (*) before the affected segment. It uses the <object
type="tNPRuleLevelNDoubleBar"
></object
> level because these segments are adjoined at the end of the word, like an appendix.</pc
><p
>Finally, the order in which the rules occur is important. The items are in order of application: the first to be tried is higher and the last to be tried is lower. You control the order of the rules by clicking on a rule in the middle pane and then using the up and down arrows to change its order. Note that the normal way of sorting by a column via clicking on a column header is disabled for this view.</p
></section2
><section2
id="sNPFilters"
><secTitle
>NP filters</secTitle
><p
><indexedItem
term="iNPFilter"
></indexedItem
>The set of filters for the <object
type="tNPApproach"
></object
> is a completely different set of filters from those used by the <object
type="tONCApproach"
></object
> and the <object
type="tMoraicApproach"
></object
>. <object
type="tNPFilters"
></object
> can be used for onsets, codas, and rimes in <object
type="tAsheninka"
></object
> with the <object
type="tNPApproach"
></object
>. More precisely, <object
type="tNPFilters"
></object
> are applied to rules whose <object
type="tNPRuleLevel"
></object
> is either <object
type="tNPRuleLevelNBar"
></object
> or <object
type="tNPRuleLevelNDoubleBar"
></object
>. Every <object
type="tNPFilter"
></object
> is a fail filter. There are no repair filters in the <object
type="tNPApproach"
></object
>.</p
><p
>You define filters in a similar way to the filters for the <object
type="tONCApproach"
></object
> and <object
type="tMoraicApproach"
></object
>. See <sectionRef
sec="sONCFilters"
></sectionRef
> for more on using filters.</p
><p
>One other difference is that for <object
type="tNPFilters"
></object
>, you can use the underscore character ( _ ) at the point before the first segment or class which is being attached or augmented. <indexedItem
term="iEnglish"
></indexedItem
>For example, in an English IPA project, there is an <object
type="tNPFilter"
></object
> which fails whenever an alveo-palatal is to be added before a sonorant. This is to handle cases like <langData
lang="lIPA"
>kæʃlɛs</langData
> (<langData
lang="lEnglishExmple"
>cashless</langData
>) which should be syllabified as <langData
lang="lIPA"
>kæʃ.lɛs</langData
>, not as <langData
lang="lIPA"
>kæ.ʃlɛs</langData
> and <langData
lang="lIPA"
>maɹʃlænd</langData
> (<langData
lang="lEnglishExmple"
>marshland</langData
>) which should be syllabified as <langData
lang="lIPA"
>maɹʃ.lænd</langData
>, not <langData
lang="lIPA"
>maɹ.ʃlænd</langData
>. As an initial attempt, we might write this filter as in example <exampleRef
letter="xNPFilterPlain"
num="xNPFilterPlain"
></exampleRef
>. This says that when we are about to add a segment that is a member of the Alveo-palatal class and is immediately followed by a segment which is a member of the Sonorant class, do not add it.</p
><example
num="xNPFilterPlain"
><chart
>[Alveo-palatal] [Sonorant]</chart
></example
><pc
>If we write this onset filter like this, we will discover that words such as <langData
lang="lIPA"
>ʃɹəb</langData
> (<langData
lang="lEnglishExmple"
>shrub</langData
>) will fail to syllabify (the filter blocks adding <langData
lang="lIPA"
>ʃ</langData
> as an onset). To overcome this, we can write the filter as in example <exampleRef
letter="xNPFilterConstituent"
num="xNPFilterConstituent"
></exampleRef
>.</pc
><example
num="xNPFilterConstituent"
><chart
>*[V] (*[Sonorant]) _ [Alveo-palatal] [Sonorant]</chart
></example
><pc
>What comes before the underscore is the preceding context (a vowel with an optionally following sonorant). Since a word like <langData
lang="lIPA"
>ʃɹəb</langData
> does not meet this context, the filter will not block the <langData
lang="lIPA"
>ʃ</langData
> being added as an onset. Notice that for both <langData
lang="lIPA"
>kæʃlɛs</langData
> and <langData
lang="lIPA"
>maɹʃlænd</langData
>, the context is met and so the filter does block adding the <langData
lang="lIPA"
>ʃ</langData
> as desired.</pc
></section2
><section2
id="sNPWords"
><secTitle
>NP words</secTitle
><p
><indexedItem
term="iNPWords"
></indexedItem
>This works like the <object
type="tCVWords"
></object
> view for the <object
type="tCVPatternApproach"
></object
>, except that the <object
type="tPredictedSyllableBreaks"
></object
> values, the <object
type="tParserResult"
></object
> values, and the <object
type="tParserTreeDiagram"
></object
> are the result of the <object
type="tNPApproach"
></object
> algorithm. If the parse fails and some word structure was built, then this partial word structure is shown by <object
type="tParserTreeDiagram"
></object
>. In the tree diagram, a syllable always has onsets attached to <object
type="tNPRuleLevelNDoubleBar"
></object
>, a nucleus attached to <object
type="tNPRuleLevelN"
></object
> and codas attached to <object
type="tNPRuleLevelNBar"
></object
>. Any adjoined segments will show the adjoined level. See <sectionRef
sec="sCVWords"
></sectionRef
> for more on this view.</p
></section2
><section2
id="sNPPredicitedVsCorrect"
><secTitle
>Predicted vs.​ correct NP words</secTitle
><p
><indexedItem
term="iNPPredictedVsCorrect"
></indexedItem
><indexedItem
term="iNPPredictedSyllabificationCompare"
></indexedItem
>The <object
type="tNPPredictedVsCorrectWords"
></object
> view shows any words which have both a predicted value and a correct value and, in addition, the two values differ. This is intended to give you a way to quickly see how the results of applying the <object
type="tNPApproach"
></object
> differ from the expected results. In this view the predicted and correct words are aligned in pairs with the predicted syllabification immediately above the correct syllabification. This is an attempt to make it easier to see the differences between the two.</p
></section2
><section2
id="sNPGraphemeNaturalClasses"
><secTitle
>Grapheme natural classes</secTitle
><p
><indexedItem
term="iNPGraphemes"
></indexedItem
>This works exactly like the <object
type="tGraphemeNaturalClasses"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sGraphemeNaturalClasses"
></sectionRef
> for details.</p
></section2
><section2
id="sNPEnvironments"
><secTitle
>Environments</secTitle
><p
><indexedItem
term="iNPEnvironments"
></indexedItem
>This works exactly like the <object
type="tEnvironments"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sEnvironments"
></sectionRef
> for details.</p
></section2
><section2
id="sNPTryAWord"
><secTitle
>NP Try a Word</secTitle
><p
><indexedItem
term="iNPTryAWord"
></indexedItem
><indexedItem
term="iTryAWord"
></indexedItem
>There are times when it may be difficult to know just why a given word is not syllabifying correctly. That's where the <object
type="tTryAWord"
></object
> dialog box can be useful. To see it, use the <object
type="tMenuItem"
>Parser / Try a Word</object
> menu item. This brings up a dialog box like the one shown in example <exampleRef
letter="xNPTryAWord"
num="xNPTryAWord"
></exampleRef
>. Unlike most dialog boxes, you can keep the <object
type="tTryAWord"
></object
> dialog box open while still editing other views in the main window. Unfortunately, the minimize button does not currently work so you cannot minimize the dialog, but you can drag it around and resize it. Further, the size and location of the <object
type="tTryAWord"
></object
> dialog box can be set independently for all six approaches; you can have several <object
type="tTryAWord"
></object
> dialog boxes open at the same time if you wish.</p
><example
num="xNPTryAWord"
><chart
><img
src="resources/CVTryAWord1.png"
width="500"
></img
></chart
></example
><p
>You can key a word to try in the text box. By default, <object
type="tAsheninka"
></object
> shows the current word selected in the <object
type="tNPWords"
></object
> view (if you are showing that view), the current word selected in the <object
type="tNPPredictedVsCorrectWords"
></object
> view (if you are showing that view) or the last word you used (or nothing if you've never used <object
type="tTryAWord"
></object
> before and are not showing the <object
type="tNPWords"
></object
> view).</p
><p
>When you either press the <object
type="tKey"
>Enter</object
> key or click on the <object
type="tButton"
>Try it</object
> button, <object
type="tAsheninka"
></object
> will try to parse the word in the text box and report the result in the Results portion of the dialog box.</p
><p
>For the <object
type="tNPApproach"
></object
>, there are at most two steps that are tried:</p
><ol
><li
>Parsing into segments.</li
><li
>Parsing segments into syllables (via the nuclear projection algorithm; see appendix <appendixRef
app="aNPAlgorithm"
></appendixRef
> below).</li
></ol
><p
>The results portion always shows the parsing into segments. If this succeeded, then it also shows the parsing of segments into syllables. Successful steps are shown in <object
type="tGreen"
></object
> while unsuccessful ones are shown in <object
type="tRed"
></object
>. An example of a successful parse is shown in example <exampleRef
letter="xNPTryAWordahwiyak1"
num="xNPTryAWordahwiyak1"
></exampleRef
>.</p
><example
num="xNPTryAWordahwiyak1"
><chart
><img
src="resources/NPTryAWord2.png"
width="500"
></img
></chart
></example
><p
><indexedItem
term="iFailureNPSegmenter"
></indexedItem
>The parsing into segments part is exactly the same as it is for the <object
type="tCVPatternApproach"
></object
>. If any constituent structure was built during the parse, the tree diagram is also shown. The <object
type="tCategory"
>W</object
> constituent is the word and the <object
type="tCategory"
>σ</object
> constituent indicates a syllable. A syllable will have <object
type="tNPRuleLevelNDoubleBar"
></object
>, <object
type="tNPRuleLevelNBar"
></object
>, and <object
type="tNPRuleLevelN"
></object
> constituents. Onset segments attach to an <object
type="tNPRuleLevelNDoubleBar"
></object
> level, nucleus segments attach to an <object
type="tNPRuleLevelN"
></object
>, and coda segments attach to a <object
type="tNPRuleLevelNBar"
></object
> level. Below these are the segment and then its grapheme. If the parse succeeded, then the segments and their graphemes are shown in green. If the parse failed but some of the tree was built, then the segments and their graphemes are shown in red.</p
><p
>Scrolling the results window down shows the next part:</p
><example
num="xNPTryAWordahwiyak2"
><chart
><img
src="resources/NPTryAWord3.png"
width="500"
></img
></chart
></example
><pc
>Whenever a rule is applied, its name is shown in a row by itself. In <exampleRef
letter="xNPTryAWordahwiyak2"
num="xNPTryAWordahwiyak2"
></exampleRef
>, it is the first rule which builds a nucleus on each vowel. The resulting tree diagram is shown for each step. Note that in this case, the rule is applied as it matches an affected segment from left to right. <object
type="tNPRuleActionAugment"
></object
> rules at the <object
type="tNPRuleLevelNDoubleBar"
></object
> level and all <object
type="tNPRuleActionLeftAdjoin"
></object
> rules are applied right to left. Scrolling down more, shows the next part:</pc
><example
num="xNPTryAWordahwiyak3"
><chart
><img
src="resources/NPTryAWord4.png"
width="500"
></img
></chart
></example
><pc
>This shows the onset rule being applied. The first row shows the checking of the SSP. It shows the sequence of segment pairs that were found along with their respective natural class and relationship. The <object
type="tBold"
>Relation</object
> column uses mathematical symbols to indicate the relationship as given in example <exampleRef
letter="xNPTryAWordRelation"
num="xNPTryAWordRelation"
></exampleRef
>.</pc
><example
num="xNPTryAWordRelation"
><table
border="1"
><tr
><th
align="center"
>Relation</th
><th
>Meaning</th
></tr
><tr
><td
align="center"
>&lt;</td
><td
>Segment 1 is less sonorous than segment 2.</td
></tr
><tr
><td
align="center"
>=</td
><td
>Segment 1 is equal in sonority to segment 2.</td
></tr
><tr
><td
align="center"
>&gt;</td
><td
>Segment 1 is more sonorous than segment 2.</td
></tr
><tr
><td
align="center"
>!!!</td
><td
>The segment was not in any natural class.</td
></tr
></table
></example
><pc
>Scrolling down further shows the next part:</pc
><example
num="xNPTryAWordahwiyak4"
><chart
><img
src="resources/NPTryAWord5.png"
width="500"
></img
></chart
></example
><pc
>This shows the result of the coda rule and that the other two rules did not apply to any segments.</pc
><p
>As mentioned above, whenever one of the two steps fails, there is an error message shown for that step. Depending on the error and the state of the parser at the time, more steps may or may not be tried. See <sectionRef
sec="sCVTryAWord"
></sectionRef
> for examples where the segments could not be parsed.</p
><p
><indexedItem
term="iFailureNPNaturalClasser"
></indexedItem
>If a word contains a segment that is not in any natural class, the results table will end with a row whose <object
type="tBold"
>Relation</object
> column contains “!!!” in red and one of the offending segments will have “(No Natural Class)” after it as shown in example <exampleRef
letter="xNPTryAWordNCFailure"
num="xNPTryAWordNCFailure"
></exampleRef
>.</p
><example
num="xNPTryAWordNCFailure"
><chart
><img
src="resources/NPTryAWordNCFailure.png"
width="500"
></img
></chart
></example
><pc
>In this case, the word was <langData
lang="lVernacular"
>abay</langData
>, but no natural class has the segment <langData
lang="lVernacular"
>b</langData
> in it. So when it tried to find a natural class for <langData
lang="lVernacular"
>b</langData
>, it failed</pc
></section2
></section1
><section1
id="sOTApproach"
><secTitle
><object
type="tOTApproach"
></object
></secTitle
><p
><indexedItem
term="iOTApproach"
></indexedItem
>For the <object
type="tOTApproach"
></object
>, you need to define the following items:</p
><ol
><li
>segments (<sectionRef
sec="sOTSegmentInventory"
></sectionRef
>)</li
><li
>CV Natural Classes <sectionRef
sec="sOTCVNaturalClasses"
></sectionRef
>)</li
><li
><object
type="tOTConstraints"
></object
> (<sectionRef
sec="sOTConstraints"
></sectionRef
>)</li
><li
><object
type="tOTConstraintRankings"
></object
> (<sectionRef
sec="sOTConstraintRankings"
></sectionRef
>)</li
><li
>grapheme natural classes (<sectionRef
sec="sNPGraphemeNaturalClasses"
></sectionRef
>)</li
><li
>environments (<sectionRef
sec="sNPEnvironments"
></sectionRef
>)</li
></ol
><p
>After that, you either use a existing word list, import a word list (see <sectionRef
sec="sWords"
></sectionRef
>) or enter a list of words by hand. <indexedItem
term="iParseAllWords"
></indexedItem
>Then you use the <object
type="tMenuItem"
>Parser / Parse all Words </object
> menu item or click on the <img
XeLaTeXSpecial="scaled='500'"
src="resources/SyllabifyWords.png"
></img
> tool bar button. This will apply the algorithm of the <object
type="tOTApproach"
></object
> to all the words. You can then see the results in the <object
type="tOTWords"
></object
> view. See <sectionRef
sec="sOTWords"
textBefore="plural"
></sectionRef
> and <sectionRef
sec="sOTTryAWord"
textBefore="none"
></sectionRef
> for ideas on how to check the results, among other things.</p
><p
>The main “game” to play with the <object
type="tOTApproach"
></object
> in <object
type="tAsheninka"
></object
> is to adjust the segment inventory (including graphemes and their environments), the <object
type="tOTConstraints"
></object
>, and the <object
type="tOTConstraintRankings"
></object
> so that one gets most, if not all, words to syllabify correctly.</p
><p
>In rough terms, it tries to find all possible sequences of segments in the word. If it can do that, it then seeks to apply each constraint in turn, using a similar approach to that described in <citation
ref="rHammond"
></citation
>. If every segment in the word is in a syllable, then it considers the parse a success. See appendix <appendixRef
app="aOTAlgorithm"
></appendixRef
> for details. If you are familiar with Optimality Theory, please read at least sections 4-7 of <citation
page="5-18"
ref="rHammond"
></citation
>. He explains the need for implementing OT the way it is done here. For your convenience, we include this paper with <object
type="tAsheninka"
></object
> via the <object
type="tMenuItem"
>Help / Hammond (1997)</object
>.</p
><p
>We now give more information on the various views available in the user interface for the <object
type="tOTApproach"
></object
>.</p
><section2
id="sOTSegmentInventory"
><secTitle
>OT segment inventory</secTitle
><p
><indexedItem
term="iOTSegments"
></indexedItem
>The <object
type="tCVSegmentInventory"
></object
> view works exactly like the <object
type="tCVSegmentInventory"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sCVSegmentInventory"
></sectionRef
> for details.</p
></section2
><section2
id="sOTCVNaturalClasses"
><secTitle
>CV natural classes</secTitle
><p
>The <object
type="tCVNaturalClasses"
></object
> view is exactly the same as the <object
type="tCVNaturalClasses"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See section <sectionRef
sec="sCVNaturalClasses"
></sectionRef
> for details.</p
></section2
><section2
id="sOTConstraints"
><secTitle
>OT Constraints</secTitle
><p
><indexedItem
term="iOTConstraints"
></indexedItem
><object
type="tOTConstraints"
></object
> drive the syllabification process in the <object
type="tOTApproach"
></object
>.</p
><p
>When defining an <object
type="tOTConstraint"
></object
>, you fill in the fields. The “Name” field is for you to remember this constraint. (Normally <object
type="tOTConstraint"
></object
> names are shown using small caps letters; unfortunately, we do not have a way to apply such a style automatically in the user interface.<endnote
id="nSmallCaps"
><p
>It is possible to use an overt small caps font to show these, but we have opted not to do that.</p
></endnote
> We do use small caps in <object
type="tOTTryAWord"
></object
> because it is possible there.)</p
><p
>As described in <citation
page="15-18"
ref="rHammond"
></citation
>, each <object
type="tOTConstraint"
></object
> involves one or two sets of an affected element and structural options.</p
><p
>The “Affected element 1” field lets you select the first segment or natural class that the constraint applies to. You can also indicate if the element must occur word initially and/or word finally.</p
><p
>The “Structural Options 1” check boxes let you select the set of <object
type="tOTStructuralOptions"
></object
> the constraint will remove. See <citation
page="11ff"
ref="rHammond"
></citation
> for more on the <object
type="tOTStructuralOptions"
></object
>; we use the same abbreviations here:</p
><example
num="xStructuralOptions"
><table
border="1"
><tr
><th
>Structural Option</th
><th
>Meaning</th
></tr
><tr
><td
>o</td
><td
>Onset</td
></tr
><tr
><td
>n</td
><td
>Nucleus</td
></tr
><tr
><td
>c</td
><td
>Coda</td
></tr
><tr
><td
>u</td
><td
>Unsyllabified (or unparsed)</td
></tr
></table
></example
><p
>The “Affected element 2” field is optional. When it and the “Structural Options 2” fields are set, then both elements 1 and 2 must match before the constraint will apply.</p
><p
>The “Prune element 2” check box should be checked whenever the second set of <object
type="tOTStructuralOptions"
></object
> are to be removed instead of the first set.</p
><p
><object
type="tAsheninka"
></object
> expects that the first affected element must be set and that at least one of the <object
type="tOTStructuralOptions"
></object
> for the first set must be checked. Similarly for the second set: if a second <object
type="tOTStructuralOption"
></object
> is set, then the second affected element must be set, and vice versa. Whenever <object
type="tAsheninka"
></object
> detects something awry, it will show an error message in red, suggesting what is needed. When the settings are valid, a tree diagram of the constraint will appear.</p
></section2
><section2
id="sOTConstraintRankings"
><secTitle
>OT Constraint Rankings</secTitle
><p
><indexedItem
term="iOTConstraintRankings"
></indexedItem
>The set of <object
type="tOTConstraints"
></object
> need to be placed into a ranking. While you can have multiple rankings, only the one ordered first will be used when parsing. This way, you can experiment with different rankings to see how well the syllabification of that ranking works.</p
><p
>When defining a <object
type="tOTConstraintRanking"
></object
>, you fill in the fields. The “Name” field is for you to remember this ranking.</p
><p
>Its "Description” field lets you define it more fully, perhaps including some example words as to why you added the ranking.</p
><p
>The “Constraint Ranking” field lets you select the order of the <object
type="tOTConstraints"
></object
> of this ranking. Clicking on the chooser button brings up a dialog showing the <object
type="tOTConstraints"
></object
>. The order in which the constraints occur is important. The items are in order of application: the first to be tried is higher and the last to be tried is lower. You control the order of the constraints by clicking on a constraint and then using the up and down arrows to change its order.</p
><p
>Similarly, the order in which the rankings occur is somewhat important. Only the first/topmost ranking will be used. You control the order of the rankings by clicking on a ranking in the middle pane and then using the up and down arrows to change its order. Note that the normal way of sorting by a column via clicking on a column header is disabled for this view.</p
><p
>When you create a new ranking, you will be shown a dialog box to select an existing ranking as a starting point for the new ranking.  If you click on <object
type="tButton"
>Cancel</object
>, the new ranking will be the same as the order of the list of constraints in the <object
type="tView"
>OT Contraints</object
> view.</p
></section2
><section2
id="sOTWords"
><secTitle
>OT words</secTitle
><p
><indexedItem
term="iOTWords"
></indexedItem
>This works like the <object
type="tCVWords"
></object
> view for the <object
type="tCVPatternApproach"
></object
>, except that the <object
type="tPredictedSyllableBreaks"
></object
> values, the <object
type="tParserResult"
></object
> values, and the <object
type="tParserTreeDiagram"
></object
> are the result of the <object
type="tOTApproach"
></object
> algorithm. If the parse fails and some word structure was built, then this partial word structure is shown by <object
type="tParserTreeDiagram"
></object
>. In the tree diagram, a syllable consists of the segments parsed into it. Above each segment (and its grapheme) is the structural option used. See <sectionRef
sec="sCVWords"
></sectionRef
> for more on this view.</p
></section2
><section2
id="sOTPredicitedVsCorrect"
><secTitle
>Predicted vs.​ correct OT words</secTitle
><p
><indexedItem
term="iOTPredictedVsCorrect"
></indexedItem
><indexedItem
term="iOTPredictedSyllabificationCompare"
></indexedItem
>The <object
type="tOTPredictedVsCorrectWords"
></object
> view shows any words which have both a predicted value and a correct value and, in addition, the two values differ. This is intended to give you a way to quickly see how the results of applying the <object
type="tOTApproach"
></object
> differ from the expected results. In this view the predicted and correct words are aligned in pairs with the predicted syllabification immediately above the correct syllabification. This is an attempt to make it easier to see the differences between the two.</p
></section2
><section2
id="sOTGraphemeNaturalClasses"
><secTitle
>Grapheme natural classes</secTitle
><p
><indexedItem
term="iOTGraphemes"
></indexedItem
>This works exactly like the <object
type="tGraphemeNaturalClasses"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sGraphemeNaturalClasses"
></sectionRef
> for details.</p
></section2
><section2
id="sOTEnvironments"
><secTitle
>Environments</secTitle
><p
><indexedItem
term="iOTEnvironments"
></indexedItem
>This works exactly like the <object
type="tEnvironments"
></object
> view for the <object
type="tCVPatternApproach"
></object
>. See <sectionRef
sec="sEnvironments"
></sectionRef
> for details.</p
></section2
><section2
id="sOTTryAWord"
><secTitle
>OT Try a Word</secTitle
><p
><indexedItem
term="iOTTryAWord"
></indexedItem
><indexedItem
term="iTryAWord"
></indexedItem
>There are times when it may be difficult to know just why a given word is not syllabifying correctly. That's where the <object
type="tTryAWord"
></object
> dialog box can be useful. To see it, use the <object
type="tMenuItem"
>Parser / Try a Word</object
> menu item. This brings up a dialog box like the one shown in example <exampleRef
letter="xOTTryAWord"
num="xOTTryAWord"
></exampleRef
>. Unlike most dialog boxes, you can keep the <object
type="tTryAWord"
></object
> dialog box open while still editing other views in the main window. Unfortunately, the minimize button does not currently work so you cannot minimize the dialog, but you can drag it around and resize it. Further, the size and location of the <object
type="tTryAWord"
></object
> dialog box can be set independently for all six approaches; you can have several <object
type="tTryAWord"
></object
> dialog boxes open at the same time if you wish.</p
><example
num="xOTTryAWord"
><chart
><img
src="resources/CVTryAWord1.png"
width="500"
></img
></chart
></example
><p
>You can key a word to try in the text box. By default, <object
type="tAsheninka"
></object
> shows the current word selected in the <object
type="tOTWords"
></object
> view (if you are showing that view), the current word selected in the <object
type="tOTPredictedVsCorrectWords"
></object
> view (if you are showing that view) or the last word you used (or nothing if you've never used <object
type="tTryAWord"
></object
> before and are not showing the <object
type="tOTWords"
></object
> view).</p
><p
>When you either press the <object
type="tKey"
>Enter</object
> key or click on the <object
type="tButton"
>Try it</object
> button, <object
type="tAsheninka"
></object
> will try to parse the word in the text box and report the result in the Results portion of the dialog box.</p
><p
>For the <object
type="tOTApproach"
></object
>, there are at most two steps that are tried:</p
><ol
><li
>Parsing into segments.</li
><li
>Parsing segments into syllables (via the optimality theory algorithm; see appendix <appendixRef
app="aOTAlgorithm"
></appendixRef
> below).</li
></ol
><p
>The results portion always shows the parsing into segments. If this succeeded, then it also shows the parsing of segments into syllables. Successful steps are shown in <object
type="tGreen"
></object
> while unsuccessful ones are shown in <object
type="tRed"
></object
>. An example of a successful parse is shown in example <exampleRef
letter="xOTTryAWordahwiyak1"
num="xOTTryAWordahwiyak1"
></exampleRef
>.</p
><example
num="xOTTryAWordahwiyak1"
><chart
><img
src="resources/OTTryAWord2.png"
width="500"
></img
></chart
></example
><p
><indexedItem
term="iFailureOTSegmenter"
></indexedItem
>The parsing into segments part is exactly the same as it is for the <object
type="tCVPatternApproach"
></object
>. If any constituent structure was built during the parse, the tree diagram is also shown. The <object
type="tCategory"
>W</object
> constituent is the word and the <object
type="tCategory"
>σ</object
> constituent indicates a syllable. A syllable will have one or more <object
type="tOTStructuralOptions"
></object
>. Below these are the segment and then its grapheme. If the parse succeeded, then the segments and their graphemes are shown in green. If the parse failed but some of the tree was built, then the segments and their graphemes are shown in red.</p
><p
>Scrolling the results window down shows the next part:</p
><example
num="xOTTryAWordahwiyak2"
><chart
><img
src="resources/OTTryAWord3.png"
width="500"
></img
></chart
></example
><pc
>Each step in the parse consists of two <object
type="tOTCandidateGrids"
></object
> (see <citation
page="13"
ref="rHammond"
></citation
>), one on the left (the before <object
type="tOTCandidateGrid"
></object
>) and one on the right (the after <object
type="tOTCandidateGrid"
></object
>. Any <object
type="tOTStructuralOptions"
></object
> in the <object
type="tOTCandidateGrid"
></object
> on the left which are to be removed by the constraint being applied have a background color (green if the parse succeeded; red if it failed).</pc
><p
>Every parse begins with a <object
type="tOTCandidateGrid"
></object
> with all <object
type="tOTStructuralOptions"
></object
> available. The first “constraint” is the word initial/word final housekeeping one (see <citation
page="14"
ref="rHammond"
></citation
>) that ensures codas cannot occur word initially and onsets cannot occur word finally.</p
><p
>Whenever a constraint is applied, its name is shown above the <object
type="tOTCandidateGrid"
></object
>. Scrolling down more, shows the next part:</p
><example
num="xOTTryAWordahwiyak3"
><chart
><img
src="resources/OTTryAWord4.png"
width="500"
></img
></chart
></example
><pc
>When only one <object
type="tOTStructuralOption"
></object
> remains for each segment in the <object
type="tOTCandidateGrid"
></object
>, parsing stops. It then builds the syllables as it is able and shows each one in turn.</pc
><p
>A parse fails whenever any of the following conditions occur:</p
><ul
><li
>The only <object
type="tOTStructuralOption"
></object
> remaining for some segment is “u” (i.e., it was unsyllabified or unparsed).</li
><li
>All constraints were applied and some segment still has two or more <object
type="tOTStructuralOptions"
></object
>.</li
></ul
><p
>When a word fails to parse, there will be a message at the bottom to indicate why as shown in example <exampleRef
letter="xOTTryAWordFailure"
num="xOTTryAWordFailure"
></exampleRef
>.</p
><example
num="xOTTryAWordFailure"
><chart
><img
src="resources/OTTryAWordFailure..png"
width="500"
></img
></chart
></example
></section2
></section1
><section1
id="sConvertPredictedToCorrect"
><secTitle
>Converting predicted syllabification to correct syllabification</secTitle
><p
><indexedItem
term="iCVPredictedSyllabificationConvert"
></indexedItem
>When you run the <object
type="tConvertPredictedToCorrectSyllabifcation"
></object
> tool either by using the <object
type="tMenuItem"
>Tools / Convert predicted to correct syllabification</object
> menu item or by clicking on the <img
XeLaTeXSpecial="scaled='500'"
src="resources/ConvertPredictedToCorrect.png"
></img
> tool bar button, it brings up a dialog box listing all the words which have a non-empty <object
type="tPredictedSyllableBreaks"
></object
> field and that differ from any non-empty <object
type="tCorrectSyllableBreaks"
></object
>. You can select which words should be converted by manually checking the box before them<endnote
id="nCheckingBox"
><p
>To check the box, either click in it or click in the row and press the space bar.</p
></endnote
> or by clicking on the checkbox in the header row and choosing to “Select All”, "Clear All”, or “Toggle”:</p
><ol
><li
>“Select All” checks every word.</li
><li
>“Clear All” unchecks every word.</li
><li
>“Toggle” makes every word that is checked be unchecked and every word that is unchecked be checked.</li
></ol
><p
>When you click on the OK button, <object
type="tAsheninka"
></object
> will copy the value in the <object
type="tPredictedSyllableBreaks"
></object
> field of every word that is checked to the corresponding <object
type="tCorrectSyllableBreaks"
></object
> field.</p
></section1
><section1
id="sProjectManagement"
><secTitle
>Project management</secTitle
><p
><indexedItem
term="iPMBackup"
></indexedItem
><indexedItem
term="iPMRestore"
></indexedItem
>Feel free to make frequent (labeled) backups via the <object
type="tMenuItem"
>File / Project Management / Back up this project</object
> menu item. It will bring up a dialog box like the one shown in example <exampleRef
letter="xBackUpProject"
num="xBackUpProject"
></exampleRef
>. Please give it a descriptive label so you can later identify the state of your project when you made the backup. (You can key language data if you wish.) You won't see the label on the file name, though. Rather, you'll see it when you go to the <object
type="tMenuItem"
>File / Project Management / Restore a project</object
> menu item.</p
><example
num="xBackUpProject"
><chart
><img
src="resources/BackupProject.png"
width="400"
></img
></chart
></example
><p
>When you restore a project, you will see a dialog box something like the one shown in example <exampleRef
letter="xRestoreAProject"
num="xRestoreAProject"
></exampleRef
>.</p
><example
num="xRestoreAProject"
><chart
><img
src="resources/RestoreAProject.png"
width="600"
></img
></chart
></example
><p
>The backups you have made for this project will be shown in the list. The content in the Description column is the description you keyed while making the backup.</p
><p
>The idea here is that you can make a backup, try something else (e.g., add a segment or class; or re-order the syllable patterns or add a new one), and see how it goes. If it's worse, just restore to the previous state. If it's better, make a backup of that and go on.</p
></section1
><section1
id="sWords"
><secTitle
>Importing and exporting words</secTitle
><p
>When using <object
type="tAsheninka"
></object
>, of course, you need words to parse. Once they are parsed and you have set the correct syllabifications for them (see <sectionRef
sec="sConvertPredictedToCorrect"
></sectionRef
>), you may want to export the set of words to be used by a typesetting tool. Such a tool can use the syllabified words as a list of words with discretionary hyphens so that it can know when to hyphenate long words at ends of lines.</p
><section2
id="sWordsImport"
><secTitle
>Import words</secTitle
><p
><indexedItem
term="iImport"
></indexedItem
><object
type="tAsheninka"
></object
> allows you to import a list of words in the following forms:</p
><ol
><li
><indexedItem
term="iImportTextFile"
></indexedItem
>A text file with one word per line</li
><li
><indexedItem
term="iImportParaTExt"
></indexedItem
>A word list exported from <object
type="tParatext"
></object
></li
><li
><indexedItem
term="iImportParaTExt"
></indexedItem
>The hyphenatedWords.txt file from <object
type="tParatext"
></object
></li
><li
><indexedItem
term="iImportFLEx"
></indexedItem
>A word list exported from <object
type="tFieldWorks"
>FieldWorks Language Explorer</object
> (aka FLEx) (in tab-delimited form)</li
></ol
><p
>You can use any or all of these to add words to <object
type="tAsheninka"
></object
>'s list of words. A given word form will only be inserted once. By “word form” we mean that word pairs such as <langData
lang="lVernacular"
>achto</langData
> and <langData
lang="lVernacular"
>Achto</langData
> will be considered different since their capitalization is distinct.</p
><p
>To import a word list, use <object
type="tMenuItem"
>File / Import Words</object
> menu item and then choose the type of import to use. In each case, a standard file open dialog will appear. Find the file that has the format you need, choose it, and click on “Open”. Depending on the number of words in the imported file, this may take a while to complete.</p
><p
>If you are working on a word list found in <object
type="tParatext"
></object
>, we recommend using the hyphenatedWords.txt file method. This file includes both upper and lower case forms of words and also will include any hyphenation the <object
type="tParatext"
></object
> user has manually approved. At least with some versions of <object
type="tParatext"
></object
>, this file can be found in the “My Paratext Projects” folder and then in the folder of your project name.</p
><p
>Newly added words will appear in the three words views (<object
type="tCVWords"
></object
>, <object
type="tSHWords"
></object
>, and <object
type="tONCWords"
></object
>) with a <object
type="tParserResult"
></object
> showing <object
type="tErrorMessage"
>Untested</object
>. This means that the parser has not yet been run on the word.</p
></section2
><section2
id="sWordsExport"
><secTitle
>Export words</secTitle
><p
><indexedItem
main="yes"
term="iExport"
></indexedItem
>When you want to export the word list in <object
type="tAsheninka"
></object
> to some kind of typesetting tool, use the <object
type="tMenuItem"
>File / Export Hyphenated Words</object
> menu item. The list of hyphenated words can be exported in three formats:</p
><ol
><li
><indexedItem
main="yes"
term="iExportInDesign"
></indexedItem
><indexedItem
main="yes"
term="iExportTextFile"
></indexedItem
>Export for <object
type="tInDesign"
></object
> (simple list)</li
><li
><indexedItem
main="yes"
term="iExportParaTExt"
></indexedItem
>Export for <object
type="tParatext"
></object
> (hyphenatedWords.txt)</li
><li
><indexedItem
main="yes"
term="iExportXLingPaper"
></indexedItem
>Export for <object
type="tXLingPaper"
></object
> (hyphenations exception file)</li
></ol
><p
><object
type="tAsheninka"
></object
> exports hyphenated words in the following way:</p
><ol
><li
>When the word has a value in <object
type="tCorrectSyllableBreaks"
></object
>, that value is used.</li
><li
>If <object
type="tCorrectSyllableBreaks"
></object
> is empty, then if there is a value in <object
type="tPredictedSyllableBreaks"
></object
> for the currently selected approach, it uses that value.</li
><li
>Otherwise, it does not export the word.</li
></ol
><pc
><indexedItem
term="iHPDiscretionaryHyphen"
></indexedItem
>It also will replace the periods used to demarcate syllables with whatever you have set as the discretionary hyphen character(s) in the hyphenation parameters (see <sectionRef
sec="sHyphenationParameters"
></sectionRef
>). By default, <object
type="tAsheninka"
></object
> uses an equals sign for both <object
type="tParatext"
></object
> and <object
type="tInDesign"
></object
> and a hyphen for the <object
type="tXLingPaper"
></object
> output.</pc
><p
><indexedItem
term="iHPStart"
></indexedItem
><indexedItem
term="iHPStop"
></indexedItem
>Further, <object
type="tAsheninka"
></object
> will not insert a discretionary hyphen if it appears too close to the front or too close to the end of a word, depending on the hyphenation parameters set. By default, the <object
type="tInDesign"
></object
> export uses zero characters from the front and zero characters from the end (i.e., every potential discretionary hyphen position is used).<endnote
id="nInDesign"
><p
>This is because the <object
type="tInDesign"
></object
> program has its own way of letting the typesetter control where discretionary hyphens will be used.</p
></endnote
> By default, both the <object
type="tParatext"
></object
> and <object
type="tXLingPaper"
></object
> export methods limit discretionary hyphens from two characters from the front and two characters from the back.</p
></section2
></section1
><section1
id="sOtherTools"
><secTitle
>Other tools</secTitle
><p
><object
type="tAsheninka"
></object
> also offers three other tools not previously covered.</p
><section2
id="sFindWord"
><secTitle
>Find a word</secTitle
><p
><indexedItem
term="iFindAWord"
></indexedItem
>Use the <object
type="tMenuItem"
>Tools / Find Word</object
> menu item or key <object
type="tKey"
>Ctrl F</object
> or click on the <img
XeLaTeXSpecial="scaled='500'"
src="resources/FindWord.png"
></img
> button on the toolbar to find a particular word. This brings up a dialog box which allows you to start typing the word you are looking for. As you type, it has a drop down area showing all words which contain the sequence of characters you have typed. If you are currently showing the <object
type="tCVPredictedVsCorrectWords"
></object
>, <object
type="tSHPredictedVsCorrectWords"
></object
>, or <object
type="tONCPredictedVsCorrectWords"
></object
> view, then it only uses those words in this view. If you are showing any other view, it shows all words which match what you type. Note that it shows all words which have this sequence anywhere in them, not just at the beginning. For example, with one project when I typed “<object
type="tKey"
>ach</object
>”, what is in example <exampleRef
letter="xFindWordSample"
num="xFindWordSample"
></exampleRef
> showed.</p
><example
num="xFindWordSample"
><chart
><img
src="resources/FindWordSample.png"
></img
></chart
></example
><p
>This can be very useful not only for finding a particular word, but also for looking for particular sequences of characters. A potentially better option for the latter, however, is described in <sectionRef
sec="sColumnFiltering"
></sectionRef
>.</p
><p
>When your press the <object
type="tKey"
>Enter</object
> key or click on the <object
type="tButton"
>OK</object
> button, <object
type="tAsheninka"
></object
> will show the selected word in the approach you last used: either via the <object
type="tCVWords"
></object
> view of the <object
type="tCVPatternApproach"
></object
>, the <object
type="tSHWords"
></object
> view of the <object
type="tSHApproach"
></object
>, or the <object
type="tONCWords"
></object
> view of the <object
type="tONCApproach"
></object
>. The exception is if you currently selected any of the predicted vs.​ correct views, it will select the chosen word in that view.</p
><p
><indexedItem
term="iFiltersColumns"
></indexedItem
>If you happen to have any filters set on any word columns (see <sectionRef
sec="sColumnFiltering"
></sectionRef
>) and the word you chose is not currently in the list of filtered words, then <object
type="tAsheninka"
></object
> will show a dialog box indicating that the word is hidden. You can remove all filters to show that word or you can cancel the process of finding that word.</p
></section2
><section2
id="sRemoveAllWords"
><secTitle
>Remove all words</secTitle
><p
><indexedItem
term="iRemoveWords"
></indexedItem
>Use the <object
type="tMenuItem"
>Tools / Remove all words</object
> menu item to completely clear the list of words in the <object
type="tCVWords"
></object
> view, the <object
type="tSHWords"
></object
> view and the <object
type="tONCWords"
></object
> view. When you invoke this menu item, it will show the dialog box shown in example <exampleRef
letter="xRemoveAllWords"
num="xRemoveAllWords"
></exampleRef
>.</p
><example
num="xRemoveAllWords"
><chart
><img
height="200"
src="resources/RemoveAllWords.png"
></img
></chart
></example
><p
>When you click on the <object
type="tButton"
>Yes</object
> button, <object
type="tAsheninka"
></object
> will then show you the backup dialog box (see <sectionRef
sec="sProjectManagement"
></sectionRef
>). When you have done the backup, <object
type="tAsheninka"
></object
> will immediately remove all the words from the list of words.</p
><p
>If, instead, you click on the <object
type="tButton"
>No</object
> button, <object
type="tAsheninka"
></object
> will immediately remove all the words from the list of words.</p
><p
>Note that when the words are removed, it will happen whether or not the <object
type="tCVWords"
></object
> view, the <object
type="tSHWords"
></object
> view, or the <object
type="tONCWords"
></object
> view is currently being shown. It usually happens very quickly.</p
><p
>If you click on the <object
type="tButton"
>Cancel</object
> button (or close the dialog box using the X in the red area), the dialog box will exit and nothing will change.</p
></section2
><section2
id="sRemoveCorrectSyllabifcation"
><secTitle
>Remove correct syllable breaks in all words</secTitle
><p
><indexedItem
term="iRemoveCorrectSyllabificationAllWords"
></indexedItem
>Use the <object
type="tMenuItem"
>Tools / Remove correct syllable breaks in all words</object
> menu item to completely clear the <object
type="tCorrectSyllableBreaks"
></object
> column in the <object
type="tCVWords"
></object
> view, the <object
type="tSHWords"
></object
> view, and the <object
type="tONCWords"
></object
> view. When you invoke this menu item, it will show the dialog box shown in example <exampleRef
letter="xRemoveCorrectSyllabification"
num="xRemoveCorrectSyllabification"
></exampleRef
>.</p
><example
num="xRemoveCorrectSyllabification"
><chart
><img
height="200"
src="resources/RemoveCorrectSyllabification.png"
></img
></chart
></example
><p
>Like the dialog box for removing all words in <sectionRef
sec="sRemoveAllWords"
></sectionRef
>, you are asked whether or not to make a backup. When you click on the <object
type="tButton"
>Yes</object
> button, <object
type="tAsheninka"
></object
> will then show you the backup dialog box (see <sectionRef
sec="sProjectManagement"
></sectionRef
>). When you have done the backup, <object
type="tAsheninka"
></object
> will immediately remove all the <object
type="tCorrectSyllableBreaks"
></object
> forms from the list of words.</p
><p
>If, instead, you click on the <object
type="tButton"
>No</object
> button, <object
type="tAsheninka"
></object
> will immediately remove all the <object
type="tCorrectSyllableBreaks"
></object
> forms from the list of words.</p
><p
>Note that when the <object
type="tCorrectSyllableBreaks"
></object
> forms are removed, it will happen whether or not the <object
type="tCVWords"
></object
> view, the <object
type="tSHWords"
></object
> view, or the <object
type="tONCWords"
></object
> view is currently being shown. It usually happens very quickly.</p
><p
>If you click on the <object
type="tButton"
>Cancel</object
> button (or close the dialog box using the X in the red area), the dialog box will exit and nothing will change.</p
></section2
><section2
id="sCompareImplementations"
><secTitle
>Compare two implementations</secTitle
><p
><indexedItem
term="iCompare2Implementations"
></indexedItem
><object
type="tAsheninka"
></object
> offers a way to more easily see what some changes to an approach have on how the words are syllabified. Use the <object
type="tMenuItem"
>Tools / Compare Implementations</object
> menu item to do this. It brings up a dialog box which looks like what is in example <exampleRef
letter="xCompareImplementationsInitial"
num="xCompareImplementationsInitial"
></exampleRef
>.</p
><example
num="xCompareImplementationsInitial"
><chart
><img
src="resources/CompareImplementationsInitial.png"
></img
></chart
></example
><p
>You can compare the current implementation (i.e., what is showing in the user interface right now) with what is in a backup file (see <sectionRef
sec="sProjectManagement"
></sectionRef
>) or you can compare two different backups. As you can see in example <exampleRef
letter="xCompareImplementationsInitial"
num="xCompareImplementationsInitial"
></exampleRef
>, the current implementation is set by default. To compare two backups, click on the <object
type="tField"
>Choose a backup</object
> radio button.</p
><p
>Whenever you need to select a backup file, click on the <object
type="tField"
>Browse</object
> button. This will bring up the <object
type="tField"
>Restore a Project</object
> dialog. Choose the backup you want and click OK.</p
><p
>When you have chosen the two implementations to compare, click on the “Compare” button. Depending on how many differences there are, the comparison process can take quite a long time so please be patient. When it is done, a report is shown in the bottom part of the dialog. The dialog box will stay visible until you close it (e.g., by clicking on the “Cancel” button). This lets you examine the report while still being able to make changes to the data in the user interface.</p
><p
>Which approach is used in the comparison is the current one being shown.</p
><section3
id="sCVCompare"
><secTitle
><object
type="tCVPatternApproach"
></object
> comparison</secTitle
><p
><indexedItem
term="iCVCompare2Implementstions"
></indexedItem
>When I did this for one project using the <object
type="tCVPatternApproach"
></object
>, I got what is shown in example <exampleRef
letter="xCompareImplementationsResult"
num="xCompareImplementationsResult"
></exampleRef
>.</p
><example
num="xCompareImplementationsResult"
><chart
><img
src="resources/CompareImplementationsResult.png"
width="500"
></img
></chart
></example
></section3
><section3
id="sSHCompare"
><secTitle
><object
type="tSHApproach"
></object
> comparison</secTitle
><p
>When I did this for one project while showing the <object
type="tSHApproach"
></object
>, I got what is shown in example <exampleRef
letter="xSHCompareImplementationsResult"
num="xSHCompareImplementationsResult"
></exampleRef
>.</p
><example
num="xSHCompareImplementationsResult"
><chart
><img
src="resources/SHCompareImplementationsResult.png"
width="500"
></img
></chart
></example
></section3
><section3
id="sONCCompare"
><secTitle
><object
type="tONCApproach"
></object
> comparison</secTitle
><p
>When I did this for one project while showing the <object
type="tONCApproach"
></object
>, I got what is shown in example <exampleRef
letter="xONCCompareImplementationsResult"
num="xONCCompareImplementationsResult"
></exampleRef
>.</p
><example
num="xONCCompareImplementationsResult"
><chart
><img
src="resources/ONCCompareImplementationsResult.png"
width="500"
></img
></chart
></example
></section3
><section3
id="sMoraicCompare"
><secTitle
><object
type="tMoraicApproach"
></object
> comparison</secTitle
><p
>When I did this for one project while showing the <object
type="tMoraicApproach"
></object
>, I got what is shown in example <exampleRef
letter="xMoraicCompareImplementationsResult"
num="xMoraicCompareImplementationsResult"
></exampleRef
>.</p
><example
num="xMoraicCompareImplementationsResult"
><chart
><img
src="resources/MoraicCompareImplementationsResult.png"
width="500"
></img
></chart
></example
></section3
><section3
id="sNPCompare"
><secTitle
><object
type="tNPApproach"
></object
> comparison</secTitle
><p
>When I did this for one project while showing the <object
type="tNPApproach"
></object
>, I got what is shown in example <exampleRef
letter="xNPCompareImplementationsResult"
num="xNPCompareImplementationsResult"
></exampleRef
>.</p
><example
num="xNPCompareImplementationsResult"
><chart
><img
src="resources/NPCompareImplementationsResult.png"
width="500"
></img
></chart
></example
></section3
><section3
id="sOTCompare"
><secTitle
><object
type="tOTApproach"
></object
> comparison</secTitle
><p
>When I did this for one project while showing the <object
type="tOTApproach"
></object
>, I got what is shown in example <exampleRef
letter="xOTCompareImplementationsResult"
num="xOTCompareImplementationsResult"
></exampleRef
>.</p
><example
num="xOTCompareImplementationsResult"
><chart
><img
src="resources/OTCompareImplementationsResult.png"
width="500"
></img
></chart
></example
></section3
></section2
><section2
id="sCompareSyllabificationResults"
><secTitle
>Compare syllabification results between approaches</secTitle
><p
><indexedItem
term="iCompareApproaches"
></indexedItem
><object
type="tAsheninka"
></object
> also offers a way to more easily see how the words are syllabified between the approaches. Use the <object
type="tMenuItem"
>Tools / Compare Syllabification Results between Approaches</object
> menu item to do this. This immediately does a comparison of the predicted syllabification of all words and shows the result in a dialog box. In one implementation I did, it looked like what is in example <exampleRef
letter="xCompareSyllabifications"
num="xCompareSyllabifications"
></exampleRef
>.</p
><example
num="xCompareSyllabifications"
><chart
><img
src="resources/CompareSyllabifications.png"
width="500"
></img
></chart
></example
><p
>Note that you can choose which approaches to use in the comparison. In the example, all currently implemented approaches were chosen. The result shows only those words which had some difference between the parses. For each such difference, it shows each word with the result of how each chosen approach parsed it. In the case above, no vowel initial words were allowed in the <object
type="tCVPatternApproach"
></object
> so that's why there were so many failures. Scrolling down more in the dialog, there was the following portion, which better illustrates the differences:</p
><example
num="xCompareSyllabifications2"
><chart
><img
src="resources/CompareSyllabifications2.png"
width="500"
></img
></chart
></example
><p
>Like several other dialog boxes in <object
type="tAsheninka"
></object
>, you can keep this dialog box open while doing other things.</p
></section2
></section1
><section1
id="sColumnFiltering"
><secTitle
>Filtering word columns</secTitle
><p
><indexedItem
main="yes"
term="iFiltersColumns"
></indexedItem
>When using any of the Words views or the Predicted vs. correct views, <object
type="tAsheninka"
></object
> allows you to filter the columns containing words or syllabifications.</p
><p
>There are three ways to use one of these filters:</p
><ul
><li
>Use <object
type="tMenuItem"
>Tools</object
> and then choose any of <object
type="tMenuItem"
>Filter words</object
>, <object
type="tMenuItem"
>Filter predicted syllable breaks</object
>, <object
type="tMenuItem"
>Filter correct syllable breaks</object
> or <object
type="tMenuItem"
>Remove all filters</object
>.</li
><li
>Click on one of the filter-oriented toolbar buttons:<ul
><li
><img
XeLaTeXSpecial="scaled='200'"
src="resources/icons8-filter-64.png"
width="30"
></img
> for Filter words</li
><li
><img
XeLaTeXSpecial="scaled='200'"
src="resources/icons8-filter-64-Predicted.png"
width="30"
></img
> for Filter predicted syllable breaks</li
><li
><img
XeLaTeXSpecial="scaled='400' "
src="resources/icons8-filter-64-Correct.png"
width="30"
></img
> for Filter correct syllable breaks</li
><li
><img
XeLaTeXSpecial="scaled='200'"
src="resources/icons8-clear-filters-64.png"
width="30"
></img
> for Remove all syllable breaks</li
></ul
></li
><li
>Right-click on the column header. This brings up a context menu containing the options available for that column. For the Words views, these have an additional option to remove the filter for just the column you right-clicked on.</li
></ul
><p
>A filter dialog looks like what is in example <exampleRef
letter="xColumnFilter"
num="xColumnFilter"
></exampleRef
>.</p
><example
num="xColumnFilter"
><chart
><img
src="resources/ColumnFilter.png"
width="400"
></img
></chart
></example
><p
>You can choose to filter on the text you enter at the bottom using various methods:</p
><ol
><li
>The text occurs anywhere within the word or syllabification.</li
><li
>The text occurs at the start of the word or syllabification.</li
><li
>The text occurs at the end of the word or syllabification.</li
><li
>The text describes the entire word or syllabification.</li
><li
>The text is a regular expression which should match the word or syllabification.</li
><li
>Show only blanks.</li
><li
>Show only non-blanks.</li
></ol
><pc
>The last two methods are not available for the Words column or the Predicted vs. correct column. They are available for both the Predicted Syllable Breaks and the Correct Syllable Breaks columns.</pc
><p
>In addition, you can tell it to match upper/lower case or not.</p
><p
>Regular expressions use what is documented at <link
href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html"
>https://​docs.​oracle.​com/​javase/​8/​docs/​api/​java/​util/​regex/​Pattern.html</link
> beginning at <object
type="tItalic"
>Summary of regular-expression constructs</object
>. If the text you type cannot be parsed as a regular expression, then when you click on the OK button, an error dialog box will appear, showing where the error occurred and giving you an idea of what the problem is.</p
><p
>When creating a filter for any of the Predicted vs. correct views, <object
type="tAsheninka"
></object
> looks for matches for the shape of the word, not the shape of the syllabification (even though what is shown are syllabifications). That is, no periods are matched.</p
><p
>Whenever a filter is being applied, the column header will have a yellow background color. <object
type="tAsheninka"
></object
> will remember which filters have been used from previous sessions. It also keeps track of these filters on an approach by approach basis. That is, you can have different filters for each approach.</p
></section1
><backMatter
><appendix
id="aCVAlgorithmInDetail"
><secTitle
>CV algorithm in detail</secTitle
><p
><indexedItem
term="iCVPatternAlgorithm"
></indexedItem
><indexedItem
term="iParsingResult"
></indexedItem
>The main algorithm is as follows:</p
><ol
><li
>It does a left-to-right sweep of the word, trying to find the sequence of segments which covers the whole word. It uses the graphemes defined in the segment information to determine a match with a segment. It tries all graphemes which match at the current point it is looking at in the left-to-right sweep. It tries the longest match first, but also applies any environments associated with the grapheme. See <sectionRef
sec="sCVSegmentInventory"
></sectionRef
> for more on this. <indexedItem
term="iFailureCVSegmenter"
></indexedItem
>If it cannot find a sequence that covers the whole word, it reports an error of <object
type="tErrorMessage"
>Failure: could not parse into segments beginning at '<object
type="tItalic"
>some characters</object
></object
> and quits. The '<object
type="tItalic"
>some characters</object
>' part indicates the place in the word where it could not find a character or character sequence that matched any graphemes in any of the segments. Most likely, either there was a typo in the word or a grapheme is missing from some segment or its environment was not met. You can use the <object
type="tTryAWord"
></object
> tool to get more details (see <sectionRef
sec="sCVTryAWord"
></sectionRef
>).</li
><li
>If it succeeded in finding a sequence of segments, it then performs a left-to-right sweep of the segments it posited, trying to find a sequence of natural classes that covers the entire sequence of segments. It uses the set of segments or natural (sub-)classes defined within a natural class to determine a match with a natural class. If two or more natural classes match, it tries each of them in turn. <indexedItem
term="iFailureCVNaturalClasser"
></indexedItem
>If it cannot find a sequence of natural classes that covers the entire sequence of posited segments, it reports an error of <object
type="tErrorMessage"
>Failure: could not parse into natural classes; did find classes '<object
type="tItalic"
>some classes</object
>' covering graphemes '<object
type="tItalic"
>some graphemes</object
>'</object
> and quits. The '<object
type="tItalic"
>some classes</object
>' part indicates the sequence of natural classes that were found and the '<object
type="tItalic"
>some graphemes</object
>' part indicates which graphemes were included in those natural classes. Hopefully this will help you figure out why other natural classes were not found for this word.</li
><li
>If it succeeded in finding a sequence of natural classes, it performs a left-to-right sweep of the sequence of the natural classes it posited, trying to find a sequence of syllable patterns that covers the entire sequence. It tries the syllable patterns in the order they are arranged in the <object
type="tCVSyllablePatterns"
></object
> view (see <sectionRef
sec="sCVSyllablePatterns"
></sectionRef
> below). <indexedItem
term="iFailureCVSyllables"
></indexedItem
>If it cannot find a sequence of syllable patterns that covers the entire sequence of posited natural classes, it reports an error of <object
type="tErrorMessage"
>Failure: could not parse natural classes into syllables</object
> and quits.</li
><li
>If it succeeded in finding a sequence of syllable patterns, it outputs the syllabification into the <object
type="tPredictedSyllableBreaks"
></object
> field and reports <object
type="tSuccessMessage"
></object
>.</li
></ol
></appendix
><appendix
id="aSHAlgorithmInDetail"
><secTitle
>Sonority hierarchy algorithm in detail</secTitle
><p
><indexedItem
term="iSHPatternAlgorithm"
></indexedItem
><indexedItem
term="iParsingResult"
></indexedItem
>The main algorithm is as follows:</p
><ol
><li
>It does a left-to-right sweep of the word, trying to find the sequence of segments which covers the whole word. It uses the graphemes defined in the segment information to determine a match with a segment. It tries all graphemes which match at the current point it is looking at in the left-to-right sweep. It tries the longest match first, but also applies any environments associated with the grapheme. See <sectionRef
sec="sCVSegmentInventory"
></sectionRef
> for more on this. <indexedItem
term="iFailureCVSegmenter"
></indexedItem
>If it cannot find a sequence that covers the whole word, it reports an error of <object
type="tErrorMessage"
>Failure: could not parse into segments beginning at '<object
type="tItalic"
>some characters</object
></object
> and quits. The '<object
type="tItalic"
>some characters</object
>' part indicates the place in the word where it could not find a character or character sequence that matched any graphemes in any of the segments. Most likely, either there was a typo in the word or a grapheme is missing from some segment or its environment was not met.<endnote
id="nSHSegSameAsCV"
><p
>This is the exact same algorithm used by the <object
type="tCVPatternApproach"
></object
>.</p
></endnote
> You can use the <object
type="tTryAWord"
></object
> tool to get more details (see <sectionRef
sec="sSHTryAWord"
></sectionRef
>).</li
><li
>If it succeeded in finding a sequence of segments, it then performs a left-to-right sweep of the segments it posited. It places the first segment of the word in the first syllable. It then tries to find the natural class of the current segment and the natural class of the following segment (unless the current segment is at the end of the word and also not already in a syllable; in this case, it adds the current segment to the current syllable). It then compares the “level” in the sonority hierarchy of these two natural classes and processes them as follows:<ol
><li
>If they are at the same level, a new syllable is created and the second segment is added to this new syllable.</li
><li
>If the natural class of the current segment is less sonorous than the natural class of the following segment, then it adds the following segment to the current syllable.</li
><li
>If the natural class of the current segment is more sonorous than the natural class of the following segment, then it looks at the segment after the following segment. There are two cases considered:<ol
><li
>If the second segment's natural class is the same or more sonorous than the third segment's natural class, than the second segment is added to the current syllable. A new syllable is created and the third segment is added to it.</li
><li
>Otherwise, a new syllable is created and the second segment is added to it.</li
></ol
></li
></ol
></li
><li
>Whenever a segment is not found in any natural class, an error is reported.</li
><li
>If it succeeded in finding natural classes for all segments, it outputs the syllabification into the <object
type="tPredictedSyllableBreaks"
></object
> field and reports <object
type="tSuccessMessage"
></object
>.</li
></ol
></appendix
><appendix
id="aONCAlgorithmInDetail"
><secTitle
>ONC algorithm in detail</secTitle
><p
><indexedItem
term="iONCPatternAlgorithm"
></indexedItem
><indexedItem
term="iParsingResult"
></indexedItem
>The main algorithm for the <object
type="tONCApproach"
></object
> is as follows:</p
><ol
><li
>It does a left-to-right sweep of the word, trying to find the sequence of segments which covers the whole word. It uses the graphemes defined in the segment information to determine a match with a segment. It tries all graphemes which match at the current point it is looking at in the left-to-right sweep. It tries the longest match first, but also applies any environments associated with the grapheme. See <sectionRef
sec="sCVSegmentInventory"
></sectionRef
> for more on this. <indexedItem
term="iFailureCVSegmenter"
></indexedItem
>If it cannot find a sequence that covers the whole word, it reports an error of <object
type="tErrorMessage"
>Failure: could not parse into segments beginning at '<object
type="tItalic"
>some characters</object
></object
> and quits. The '<object
type="tItalic"
>some characters</object
>' part indicates the place in the word where it could not find a character or character sequence that matched any graphemes in any of the segments. Most likely, either there was a typo in the word or a grapheme is missing from some segment or its environment was not met.<endnote
id="nONCSegSameAsCV"
><p
>This is the exact same algorithm used by the <object
type="tCVPatternApproach"
></object
>.</p
></endnote
> You can use the <object
type="tTryAWord"
></object
> tool to get more details (see <sectionRef
sec="sONCTryAWord"
></sectionRef
>).</li
><li
>If it succeeded in finding a sequence of segments, it then looks at the first segment. If it is not an onset and the <object
type="tOnsetPrinciple"
></object
> is set to <object
type="tOPEverySyllableHasOnset"
></object
>, then it reports an error of <object
type="tErrorMessage"
>Onsets are required but segment 1 was not an onset.</object
> and quits.</li
><li
>Otherwise, it performs a left-to-right sweep of the segments. For each segment, it compares the sonority of this onset to the sonority of the following segment. What happens next depends on the onset, nucleus, or coda status of the segment.</li
><li
>it looks at the classification of the segment (onset, nucleus, and/or coda).<ol
><li
>If it can be an onset, it compares the sonority of this onset to the sonority of the following segment. If the following segment's sonority is less than or equal to this segment's sonority, this segment is added to the current syllable.</li
><li
>Otherwise, it compares the sonority of the segment to the sonority of the following segment. It also assigns a type (or state) to the segment's position, depending on what the last segment was. The types are:<ol
><li
>Onset</li
><li
>Onset or nucleus</li
><li
>Nucleus</li
><li
>Nucleus or coda</li
><li
>Coda</li
><li
>Coda or onset</li
><li
>Unknown</li
></ol
><pc
>The initial type is set to unknown.</pc
></li
><li
>Here is what it does for each type:<ol
><li
>Onset:<ol
><li
>If the segment can be an onset and its sonority is less than the sonority of the following segment, it adds the segment to the syllable as an onset. The type is set to be an onset or a nucleus.</li
><li
>Otherwise, it sets the type to be a nucleus.</li
></ol
></li
><li
>Onset or nucleus:<ol
><li
>If the segment can be an onset and its sonority is less than the sonority of the following segment, it adds the segment to the syllable as an onset. The type is set to be an onset or a nucleus.</li
><li
>Otherwise, if the segment can be a nucleus, it adds it to the syllable as a nucleus. The type is set to be a nucleus or a coda.</li
><li
>Otherwise, the parsing quits as a failure.</li
></ol
></li
><li
>Nucleus:<ol
><li
>If the segment can be a nucleus, it is added to the syllable as a nucleus. The type is set to be a nucleus or a coda.</li
><li
>Otherwise, the parsing quits as a failure.</li
></ol
></li
><li
>Nucleus or coda:<ol
><li
>If the segment can be a nucleus, it is added to the syllable as a nucleus. The type is set to be a nucleus or a coda.</li
><li
>Otherwise, if the segment can be a coda and the <object
type="tCodasAllowed"
></object
> parameter is set, then<ol
><li
>If the segment can also be an onset and it is less sonorous than the following segment:<ol
><li
>If the <object
type="tOnsetMaximization"
></object
> parameter is set, the syllable is added to the word and new a syllable is created. The type is set to onset or nucleus if the <object
type="tOnsetPrinciple"
></object
> is set to <object
type="tOPOnsetsNotRequired"
></object
>; otherwise the type is set to onset.</li
><li
>Otherwise, if the following segment is not an onset and the <object
type="tOnsetPrinciple"
></object
> is not set to <object
type="tOPOnsetsNotRequired"
></object
>, the syllable is added to the word and new a syllable is created. The type is set to onset or nucleus.</li
><li
>Otherwise, the segment is added to the syllable as a coda and a new syllable is started. The type is set to onset or nucleus if the <object
type="tOnsetPrinciple"
></object
> is set to <object
type="tOPOnsetsNotRequired"
></object
>; otherwise it is set to onset.</li
></ol
></li
><li
>Otherwise: <ol
><li
>The segment is added to the syllable as a coda and a new syllable is started. The type is set to onset or nucleus if the <object
type="tOnsetPrinciple"
></object
> is set to <object
type="tOPOnsetsNotRequired"
></object
>; otherwise the type is set to onset.</li
></ol
></li
></ol
></li
><li
>Otherwise, the syllable is added to the word, a new syllable is created and the type is set to be an onset.</li
></ol
></li
><li
>Coda or onset:<ol
><li
>If the segment can be a coda, the <object
type="tCodasAllowed"
></object
> parameter is set, and the segment is more sonorous than the following segment, it adds the segment to the syllable as a coda. The type is set to be a coda or an onset.</li
><li
>Otherwise, the segment is added to the syllable as a coda and a new syllable is started. The type is set to onset or nucleus if the <object
type="tOnsetPrinciple"
></object
> is set to <object
type="tOPOnsetsNotRequired"
></object
>; otherwise the type is set to onset.</li
></ol
></li
><li
>Coda: (This never happens actually.)</li
></ol
></li
></ol
></li
><li
>If it succeeded in processing all the segments in the word, it outputs the syllabification into the <object
type="tPredictedSyllableBreaks"
></object
> field and reports <object
type="tSuccessMessage"
></object
>.</li
></ol
><p
><indexedItem
term="iONCFilter"
></indexedItem
><indexedItem
term="iONCTemplates"
></indexedItem
>If you have defined any filters or templates, then these also are applied during this process. In particular, filters are only applied for onset, nucleus, coda, and rime constituents.</p
><p
><indexedItem
term="iONCFilter"
></indexedItem
>Filters come in two varieties: fail and repair. When a filter is matched and is marked as fail, then the syllable parsing stops at that point and seeks other possibilities, if any. When the filter matches and is marked as repair, it will seek to fix up the syllable constituents around it to fix the situation. <indexedItem
term="iEnglish"
></indexedItem
>For example, for English, a word such as <langData
lang="lEnglishExmple"
>Atlantic</langData
> (<langData
lang="lIPA"
>ætlæntɪk</langData
>) will normally syllabify as <langData
lang="lIPA"
>æ.tlæn.tɪk</langData
> but it needs to syllabify as <langData
lang="lIPA"
>æt.læn.tɪk</langData
>. By adding an onset repair filter that matches the <langData
lang="lIPA"
>tl</langData
> sequence, one can obtain the correct result.</p
><p
><indexedItem
term="iONCTemplates"
></indexedItem
>Templates can be applied to onset, nucleus, coda, word initial, and word final constituents. For nucleus, the set of slots must match. For the others, the set of slots can override the <object
type="tSHSonorityHierarchy"
></object
>.</p
></appendix
><appendix
id="aMoraicAlgorithmInDetail"
><secTitle
>Moraic algorithm in detail</secTitle
><p
><indexedItem
term="iMoraicApproachAlgorithm"
></indexedItem
><indexedItem
term="iParsingResult"
></indexedItem
>The main algorithm for the <object
type="tMoraicApproach"
></object
> is as follows:</p
><ol
><li
>It does a left-to-right sweep of the word, trying to find the sequence of segments which covers the whole word. It uses the graphemes defined in the segment information to determine a match with a segment. It tries all graphemes which match at the current point it is looking at in the left-to-right sweep. It tries the longest match first, but also applies any environments associated with the grapheme. See <sectionRef
sec="sCVSegmentInventory"
></sectionRef
> for more on this. <indexedItem
term="iFailureCVSegmenter"
></indexedItem
>If it cannot find a sequence that covers the whole word, it reports an error of <object
type="tErrorMessage"
>Failure: could not parse into segments beginning at '<object
type="tItalic"
>some characters</object
></object
> and quits. The '<object
type="tItalic"
>some characters</object
>' part indicates the place in the word where it could not find a character or character sequence that matched any graphemes in any of the segments. Most likely, either there was a typo in the word or a grapheme is missing from some segment or its environment was not met.<endnote
id="nMoraicSegSameAsCV"
><p
>This is the exact same algorithm used by the <object
type="tCVPatternApproach"
></object
>.</p
></endnote
> You can use the <object
type="tTryAWord"
></object
> tool to get more details (see <sectionRef
sec="sMoraicTryAWord"
></sectionRef
>).</li
><li
>If it succeeded in finding a sequence of segments, it then processes the segments one after the other. It starts in an “Onset” state.</li
><li
>When in the “Onset” state,<ol
><li
>If there is an onset template, it sees if the sequence of segments matches it. If it does, it tries to add the onset segments to the syllable and assumes that any following segments must be mora-bearing.</li
><li
>If no onset templates exist or match, <ol
><li
>if the segment is not mora-bearing, then:<ol
><li
>If there are syllable templates<ol
><li
>and one applies, it adds the segment as an onset;</li
><li
>if none apply, syllabification fails.</li
></ol
></li
><li
>If the sonority of this segment is less than what follows, if adds the segment as an onset;</li
><li
>otherwise, it fails to syllabify.</li
></ol
></li
><li
>Otherwise, <ol
><li
>if onsets are required at this point in the parse of the word, syllabification fails.</li
><li
>Otherwise, it will see if the segment will work as a mora-bearing segment after checking for sonority issues. That is, it changes the state to “Mora.”</li
></ol
></li
></ol
></li
></ol
></li
><li
>When in the “Mora” state,<ol
><li
>if the segment bears one or more moras,<ol
><li
>If the syllable can have another mora,<ol
><li
>if no syllable templates apply and there is at least one mora in the syllable already, finish the current syllable and start a new one. The state is changed to “Onset.”</li
><li
>Otherwise, add the segment to the syllable as a mora-bearing segment.</li
></ol
></li
><li
>If the syllable cannot have another mora (because the maximum number of moras in a syllable has been reached), then finish this syllable and start a new one. The state is changed to “Onset.”</li
></ol
></li
><li
>If the segment can be a coda,<ol
><li
>if there already is a coda segment and an onset template applies, it finishes the current syllable, creates a new one, and adds the segments matching the onset template to the new syllable. The state is changed to “Mora.”</li
><li
>If weight-by-position is in effect, and another mora can be added to the syllable, it adds the segment as mora-bearing.</li
><li
>Otherwise it adds the segment to the preceding mora in the syllable.</li
></ol
></li
><li
>Otherwise,<ol
><li
>if the syllable has at least one mora it adds the syllable to the word and starts a new syllable. The state is changed to “Onset.”<ol
><li
>If any onset templates apply, it adds the matching segments to the syllable and the state is changed to “Mora.”</li
><li
>Otherwise, if any word final templates apply, syllabification succeeds.</li
></ol
></li
><li
>Otherwise, syllabification fails.</li
></ol
></li
></ol
></li
><li
>When all of the segments have been processed, the current syllable is added to the word, if needed.</li
></ol
><p
>Whenever a segment is added to a syllable as an onset, it also tries to apply any onset repair filters and applies any onset fail filters.</p
></appendix
><appendix
id="aNPAlgorithm"
><secTitle
>Nuclear Projection algorithm in detail</secTitle
><p
><indexedItem
term="iNPApproachAlgorithm"
></indexedItem
><indexedItem
term="iParsingResult"
></indexedItem
>The main algorithm for the <object
type="tNPApproach"
></object
> is as follows:</p
><ol
><li
>For each rule:<ol
><li
>Determine the set of segments, if any, that match the affected/context/level part of the rule:<ol
><li
>If it is a <object
type="tNPRuleActionBuild"
></object
> rule, match any affected segments.</li
><li
>If it is a <object
type="tNPRuleActionAttach"
></object
> or <object
type="tNPRuleActionAugment"
></object
> rule and the level is <object
type="tNPRuleLevelNDoubleBar"
></object
>, match the affected immediately before the context.</li
><li
>If it is a <object
type="tNPRuleActionAttach"
></object
> or <object
type="tNPRuleActionAugment"
></object
> rule and the level is not <object
type="tNPRuleLevelNDoubleBar"
></object
>, match the affected immediately after the context.</li
><li
>If it is a <object
type="tNPRuleActionLeftAdjoin"
></object
> rule, match the affected immediately before the context.</li
><li
>If it is a <object
type="tNPRuleActionRightAdjoin"
></object
> rule, match the affected immediately after the context.</li
></ol
></li
><li
>For each match:<ol
><li
>If the rule must obey the SSP, check the sonority between the affected and context segments. If the affected comes before the context, then sonority must be rising. If the affected comes after the context, then the sonority must decrease.</li
><li
>If sonority passes (or is ignored), then:<ol
><li
>If it is a <object
type="tNPRuleActionBuild"
></object
> rule, create a new syllable and the constituent structure (syllable to <object
type="tNPRuleLevelNDoubleBar"
></object
> to <object
type="tNPRuleLevelNBar"
></object
> to <object
type="tNPRuleLevelN"
></object
> to the affected segment that matched).</li
><li
>If it is an <object
type="tNPRuleActionAttach"
></object
> or <object
type="tNPRuleActionAugment"
></object
> rule, apply any appropriate filters for the level (<object
type="tNPRuleLevelNDoubleBar"
></object
> is onset and <object
type="tNPRuleLevelNBar"
></object
> is rime and coda). If any filter fails, quit. Otherwise add the affected segment to the constituent structure at the rule's level.</li
><li
>If it is an <object
type="tNPRuleActionLeftAdjoin"
></object
> or <object
type="tNPRuleActionRightAdjoin"
></object
> rule, adjoin the segment to a new instance of the level node.</li
></ol
></li
></ol
></li
></ol
></li
><li
>Check every segment in the word to see if it has been made a part of a syllable. If not, fail.</li
><li
>Check the Onset Principle setting:<ol
><li
><indexedItem
term="iAllButFirst"
></indexedItem
>If the <object
type="tOPAllButFirstHasOnset"
></object
> is set, then any syllable after the first does not have an onset (i.e., a segment in the <object
type="tNPRuleLevelNDoubleBar"
></object
> level), fail.</li
><li
><indexedItem
term="iEverySyllable"
></indexedItem
>If the <object
type="tOPEverySyllableHasOnset"
></object
> is set, then if any syllable does not have an onset (i.e., a segment in the <object
type="tNPRuleLevelNDoubleBar"
></object
> level), fail.</li
><li
><indexedItem
term="iOnsetsNotRequired"
></indexedItem
>If the <object
type="tOPOnsetsNotRequired"
></object
> is set, then there is nothing to do.</li
></ol
></li
><li
>Succeed.</li
></ol
></appendix
><appendix
id="aOTAlgorithm"
><secTitle
>OT algorithm in detail</secTitle
><p
><indexedItem
term="iOTApproachAlgorithm"
></indexedItem
><indexedItem
term="iParsingResult"
></indexedItem
>The main algorithm for the <object
type="tOTApproach"
></object
> is as follows:</p
><ol
><li
>Initialize the <object
type="tOTCandidateGrid"
></object
>.</li
><li
>Apply word initial/word final housekeeping: remove the coda <object
type="tOTStructuralOption"
></object
> from the first segment in the word and the onset <object
type="tOTStructuralOption"
></object
> from the last segment of the word.</li
><li
>For each constraint in the first ranking in the <object
type="tOTConstraintRankings"
></object
>:<ol
><li
>Determine the set of segments, if any, that match the affected element(s) part of the constraint.</li
><li
>For each match:<ol
><li
>If the set of <object
type="tOTStructuralOptions"
></object
> in the constraint are exactly the same as the remaining <object
type="tOTStructuralOptions"
></object
> in the segment, do nothing.</li
><li
>Otherwise, remove any <object
type="tOTStructuralOptions"
></object
> in that segment per the <object
type="tOTStructuralOptions"
></object
> of the constraint as long as there is at least one <object
type="tOTStructuralOption"
></object
> left.</li
></ol
></li
><li
>If the "onset before coda” housekeeping applies, remove the onset.</li
><li
>If every segment has at most one <object
type="tOTStructuralOption"
></object
> in it, check no more constraints.</li
></ol
></li
><li
>Check every segment in the word to see if it has been made a part of a syllable and has at most one <object
type="tOTStructuralOption"
></object
>. If not, fail.</li
><li
>Succeed.</li
></ol
></appendix
><appendix
id="aKnownIssues"
><secTitle
>Known issues</secTitle
><p
>The following are some issues we are aware of that have yet to be fixed.</p
><ol
><li
>The <object
type="tField"
>Segment or Natural Class</object
> field in CV Natural Classes may show a class closing square bracket at the beginning of the field when the vernacular language is set to show right-to-left. Similarly, the <object
type="tField"
>Grapheme or Natural Class</object
> field will do the same.</li
></ol
></appendix
><appendix
contentType="ctSampleData"
id="aSampleDataSets"
><secTitle
>Sample data sets</secTitle
><p
><object
type="tAsheninka"
></object
> comes with some sample data sets in case you find these of value. There are two.</p
><section1
id="sSampleEnglishIPA"
><secTitle
>English IPA</secTitle
><p
>This has English words written in IPA (<citation
paren="none"
ref="rIPA"
></citation
>) per my dialect. It illustrates the need for some templates and filters which are described in the “Overview” document. You can read this document by clicking <link
href="Overview.pdf"
>here</link
> or by using the <object
type="tMenuItem"
>Help / Introduction to syllabification</object
> menu item.</p
></section1
><section1
id="sSampleAsheninka"
><secTitle
>Asheninka Pajonal</secTitle
><p
>This has an implementation for the Pajonal variety of Asheninka (ISO-639-3 code cjo). Here are some observations about it:</p
><ol
><li
>The basic syllable pattern is (C)V(V)(N).</li
><li
>Onsets are required for all syllables but the first.</li
><li
>The nasals in the coda are homorganic with the following onset. We do not actually check for this.</li
><li
>The second vowel of the nucleus is either geminate or an <langData
lang="lVernacular"
>e</langData
> which forms a diphthong with a preceding <langData
lang="lVernacular"
>a</langData
> or <langData
lang="lVernacular"
>o</langData
>.</li
><li
>No templates or filters are needed.</li
></ol
><p
>In this implementation, I chose to model the geminates and diphthongs as separate segments. The reasons for this are as follows:</p
><ol
><li
>Fewer CV syllable patterns are needed for the <object
type="tCVPatternApproach"
></object
>.</li
><li
>The <object
type="tSHApproach"
></object
> forces a syllable break whenever there are two consecutive top-level segments. Since vowels are the highest level, this means the geminates and diphthongs are broken into two syllables. This is incorrect.</li
></ol
></section1
></appendix
><appendix
id="aAsheninka"
><secTitle
>Why is it called <object
type="tAsheninka"
></object
>?</secTitle
><p
>This syllable parsing program is called <object
type="tAsheninka"
></object
> for historic reasons. (The word is pronounced <langData
lang="lVernacular"
>a.ˈʃɛ.nɪŋ.ka</langData
>.)</p
><p
>In late 1983 my family and I were living in the jungles of Peru and David Payne came and asked me if I would create a <object
type="tTool"
>Consistent Changes</object
> table for him that would insert discretionary hyphens in Asheninka text.<endnote
id="nCC"
><p
>A more current version of this program is <citation
ref="rCC"
></citation
>.</p
></endnote
> The algorithm he suggested was the CV Patterns approach (see <sectionRef
sec="sCVApproach"
></sectionRef
>). Asheninka has long words and typesetting material in that language would improve readability with such a table. In 1984 I wrote such a table.</p
><p
>While it was functional, it ran slowly. I then wrote the <object
type="tTool"
>Hyphen</object
> program (<citation
paren="none"
ref="rDocPrepAids"
></citation
>) to improve the efficiency. It implemented the same basic approach. Amazingly, the <object
type="tTool"
>Hyphen</object
> program is still being used (albeit occasionally) today.</p
><p
>Because of this beginning, I chose to call this tool <object
type="tAsheninka"
></object
>. The program icon (shown in example <exampleRef
letter="xCushma"
num="xCushma"
></exampleRef
> below) is the kind of material used for clothing by Asheninka people.<endnote
id="nCushmaImage"
><p
>This image was gratefully taken from <link
href="http://www.ecotribal.com/en/shop/ashaninka-cushma-8"
>here</link
> on 12 November, 2015.</p
></endnote
></p
><example
num="xCushma"
><chart
><img
src="CushmaSmall.jpg"
></img
></chart
></example
></appendix
><endnotes
></endnotes
><xi:include
href="CommonReferences.xml"
xpointer="element(/1)"
xmlns:xi="http://www.w3.org/2001/XInclude"
></xi:include
><index
></index
></backMatter
><xi:include
href="Languages.xml"
xpointer="element(/1)"
xmlns:xi="http://www.w3.org/2001/XInclude"
></xi:include
><xi:include
href="Types.xml"
xpointer="element(/1)"
xmlns:xi="http://www.w3.org/2001/XInclude"
></xi:include
><xi:include
href="IndexTerms.xml"
xpointer="element(/1)"
xmlns:xi="http://www.w3.org/2001/XInclude"
></xi:include
><contentControl
><contentTypes
><contentType
id="ctSampleData"
>Include sample data sets</contentType
><contentType
id="ctNoSampleData"
>No sample data sets</contentType
></contentTypes
><contentControlChoices
><contentControlChoice
active="no"
>Include sample data sets</contentControlChoice
><contentControlChoice
active="yes"
exclude="ctSampleData"
>Exclude sample data sets</contentControlChoice
></contentControlChoices
></contentControl
></lingPaper
><xi:include
href="SILInternationalPaperStylesheet.xml"
xpointer="element(/1)"
xmlns:xi="http://www.w3.org/2001/XInclude"
></xi:include
></styledPaper
></xlingpaper
>
