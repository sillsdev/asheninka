<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE xlingpaper PUBLIC "-//XMLmind//DTD XLingPap//EN"
"XLingPap.dtd">
<xlingpaper
version="2.24.0"
><styledPaper
><lingPaper
automaticallywrapinterlinears="yes"
sectionRefCapitalizedPluralLabel="Sections "
sectionRefCapitalizedSingularLabel="Section "
sectionRefDefault="singular"
sectionRefPluralLabel="sections "
sectionRefSingularLabel="section "
version="2.28.0"
><frontMatter
><title
><object
type="tAsheninka"
></object
> User Documentation</title
><author
>H. Andrew Black</author
><affiliation
>SIL International</affiliation
><emailAddress
>asheninka_support@sil.org</emailAddress
><date
>7 April 2017</date
><version
>0.4.1 Alpha</version
><contents
></contents
></frontMatter
><section1
id="sIntroduction"
><secTitle
>Introduction</secTitle
><p
>The <object
type="tAsheninka"
></object
> program is a linguistic tool with two goals:</p
><ol
><li
>Explore various syllabification algorithms.</li
><li
>Provide a principled way to insert discretionary hyphens in a list of words (which can then be used for typesetting text).</li
></ol
><p
>The first is clearly a linguistic research goal. The second is a practical application of the first goal. While one probably will want to use IPA (<citation
paren="none"
ref="rIPA"
></citation
>) for the first, the second should be done using the practical orthography.</p
></section1
><section1
id="sGeneralUserInterfaceItems"
><secTitle
>General user interface items</secTitle
><p
>This section notes some common items found in various places throughout the user interface. It also discusses some of the more basic <object
type="tMenuItem"
>File</object
>, <object
type="tMenuItem"
>Settings</object
>, and <object
type="tMenuItem"
>Help</object
> menu items.</p
><p
><indexedItem
term="iAddDataItem"
></indexedItem
>While editing data, you add a new item by using the <object
type="tMenuItem"
>Edit / New item</object
> menu item or clicking on the <img
src="resources/AddItem.png"
></img
> button. <indexedItem
term="iDeleteDataItem"
></indexedItem
>To delete an item, use the <object
type="tMenuItem"
>Edit / Remove item</object
> menu item or click on the <img
src="resources/Remove.png"
></img
> button.</p
><p
><indexedItem
term="iActiveField"
></indexedItem
>A number of these have a field called <object
type="tField"
>Active</object
>. If the checkbox is checked, then this item will be used when syllabifying. If it is not checked, then it will not be used. This lets you experiment with various possibilities.</p
><p
><indexedItem
term="iSorting"
></indexedItem
>When the view contains a pane with rows and columns, you can click on a column header to sort by that column (it currently only sorts by Unicode code point). You can even hold the Shift key down and click on another column header to get a secondary sort (or on a third column to get a tertiary sort). There are some tables which cannot be sorted because the user controls the order manually. In such cases (such as <object
type="tCVSyllablePatterns"
></object
>), the sorting is disabled.</p
><p
><object
type="tAsheninka"
></object
> will attempt to remember the location and size of the main window and most dialog boxes. So if you find that a dialog box is too small or too large, try resizing it (by dragging the edges of the window). Usually the next time you use that dialog box, it will be at the location and size you changed it to.</p
><section2
id="sNewProject"
><secTitle
>Creating a new project</secTitle
><p
><indexedItem
term="iProjectNew"
></indexedItem
><object
type="tAsheninka"
></object
> comes with a stock set of segments, etc. That is, when you create a new project, <object
type="tAsheninka"
></object
> will fill this new project with this stock set of segments, etc. You can then edit them, delete them, and add any needed items.</p
><p
>When you want to create a new project, use <object
type="tMenuItem"
>File / New</object
> menu item or click on the <img
src="resources/FileNew.png"
></img
> toolbar button. This brings up a standard “Save as...” dialog box so you can save this stock set of data as your new project. The expected file extension to use with all <object
type="tAsheninka"
></object
> files is “.ashedata” (for <object
type="tAsheninka"
></object
> data). Key the file name you want and press OK.</p
><p
>We suggest you create a directory called “My Asheninka” in your normal documents directory and put all your <object
type="tAsheninka"
></object
> projects in it.</p
></section2
><section2
id="sOpen"
><secTitle
>Opening an existing project</secTitle
><p
><indexedItem
term="iProjectOpen"
></indexedItem
>When you already have an existing <object
type="tAsheninka"
></object
> project and you want to open it into <object
type="tAsheninka"
></object
>, use the <object
type="tMenuItem"
>File / Open...</object
> menu item or click on the <img
src="resources/FileOpen.png"
></img
> toolbar button. This brings up a standard “File Open...” dialog box. Find the file you want and click on OK.</p
></section2
><section2
id="sSave"
><secTitle
>Saving a project</secTitle
><p
><indexedItem
term="iProjectSave"
></indexedItem
>While <object
type="tAsheninka"
></object
> will automatically save your work about every 30 seconds, you can also use the <object
type="tMenuItem"
>File / Save</object
> menu item or click on the <img
src="resources/Save.png"
></img
> button in the toolbar.</p
></section2
><section2
id="sSaveAs"
><secTitle
>Save a project as a new project</secTitle
><p
><indexedItem
term="iProjectSaveAs"
></indexedItem
>When you decide to save the current project with a different name, use the <object
type="tMenuItem"
>File / Save As...</object
> menu item. The resulting file will have all the data that the original project did except it will have a new name.</p
></section2
><section2
id="sLanguages"
><secTitle
>Setting fonts for vernacular and analysis language display</secTitle
><p
><indexedItem
term="iLanguageAnalysis"
></indexedItem
><indexedItem
term="iLanguageVernacular"
></indexedItem
>Use the <object
type="tMenuItem"
>Settings</object
> menu item to set the font information for displaying the vernacular and/or the analysis languages. Currently, only font family, font size, and font style can be set. We do plan to include color and sorting information in a later version.</p
></section2
><section2
id="sHyphenationParameters"
><secTitle
>Setting hyphenation parameters</secTitle
><p
><indexedItem
main="yes"
term="iHyphenationParameters"
></indexedItem
>When one <indexedItem
term="iExport"
></indexedItem
>exports syllabified words in one of three possible formats (as explained in <sectionRef
sec="sWordsExport"
></sectionRef
>), one can also control three variables for each of the three formats:</p
><ol
><li
><indexedItem
main="yes"
term="iHPDiscretionaryHyphen"
></indexedItem
>The discretionary hyphen character sequence used.</li
><li
><indexedItem
main="yes"
term="iHPStart"
></indexedItem
>The number of printable characters from the beginning of the word after which hyphenation starts.</li
><li
><indexedItem
main="yes"
term="iHPStop"
></indexedItem
>The number of printable characters from the end of the word where hyphenation stops.</li
></ol
><p
>The default values for these can be changed by using the <object
type="tMenuItem"
>Settings / Hyphenation Parameters</object
> menu item. This then shows the three export options. Choosing one brings up a dialog box showing the current hyphenation parameter settings for this export method. You can change the values and then click on the <object
type="tMenuItem"
>OK</object
> button.</p
></section2
><section2
id="sUserInterfaceLanguage"
><secTitle
>User interface language</secTitle
><p
><indexedItem
term="iLanguageUI"
></indexedItem
>You can set the user interface language by using the <object
type="tMenuItem"
>Settings / Change the interface language</object
> menu item. This brings up a dialog box showing the current interface language in a drop down chooser. Click on the chooser's drop down button to see other interface language choices. The choices given use the name of the language in the current interface language (so if the current interface language is English, then it will show “Spanish” as an option; if the current interface language is Spanish, it will show English as “inglés”).</p
><p
>The current version has English and a rough, most likely often inaccurate version of Spanish. Any corrections to the Spanish are welcome.</p
></section2
><section2
id="sHelp"
><secTitle
><object
type="tMenuItem"
>Help</object
> menu items</secTitle
><p
><indexedItem
term="iHelp"
></indexedItem
>Currently, there are four <object
type="tMenuItem"
>Help</object
> menu items:</p
><ol
><li
><indexedItem
term="iUserDoc"
></indexedItem
><object
type="tMenuItem"
>User Documentation</object
> which shows this document.</li
><li
><indexedItem
term="iTutorial"
></indexedItem
><object
type="tMenuItem"
>Suggested Stepsl</object
> which has some suggestions on how to be effective when using <object
type="tAsheninka"
></object
>.</li
><li
><indexedItem
term="iIntroduction"
></indexedItem
><object
type="tMenuItem"
>Introduction to syllabification</object
> which has some general discussion of syllabification issues.</li
><li
><object
type="tMenuItem"
>About Asheninka</object
> which has some standard information about the current version of <object
type="tAsheninka"
></object
>.</li
></ol
></section2
></section1
><section1
id="sApproaches"
><secTitle
>Approaches to syllabification</secTitle
><p
><object
type="tAsheninka"
></object
> will eventually offer six different syllabification algorithms or approaches. These are covered in <sectionRef
sec="sCVApproach"
textBefore="plural"
></sectionRef
>–<sectionRef
sec="sOTApproach"
textBefore="none"
></sectionRef
>. Only one is implemented in the current version. See <sectionRef
sec="sCVApproach"
></sectionRef
>.</p
><p
><indexedItem
term="iIntroduction"
></indexedItem
>The various approaches or algorithms are explained and illustrated in the “Overview” document. You can read this document by clicking <link
href="Overview.pdf"
>here</link
> or by using the <object
type="tMenuItem"
>Help / Introduction to syllabification</object
> menu item.</p
></section1
><section1
id="sCVApproach"
><secTitle
><object
type="tCVPatternApproach"
></object
></secTitle
><p
><indexedItem
term="iCVPatternApproach"
></indexedItem
>In the <object
type="tCVPatternApproach"
></object
>, you need to define the following items:</p
><ol
><li
>segments (<sectionRef
sec="sCVSegmentInventory"
></sectionRef
>)</li
><li
>natural classes (<sectionRef
sec="sCVNaturalClasses"
></sectionRef
>)</li
><li
>syllable patterns (<sectionRef
sec="sCVSyllablePatterns"
></sectionRef
>)</li
></ol
><p
>After that, you import a word list (see <sectionRef
sec="sWords"
></sectionRef
>) or enter a list of words by hand. Then you use the <object
type="tMenuItem"
>Parser / Syllabify Words </object
> menu item or click on the <img
src="resources/SyllabifyWords.png"
></img
> tool bar button. This will apply the algorithm of the <object
type="tCVPatternApproach"
></object
> to all the words. You can then see the results in the <object
type="tCVWords"
></object
> view. See <sectionRef
sec="sCVWords"
textBefore="plural"
></sectionRef
> and <sectionRef
sec="sCVTryAWord"
textBefore="none"
></sectionRef
> for ideas on how to check the results, among other things.</p
><p
>The main “game” to play with the <object
type="tCVPatternApproach"
></object
> in <object
type="tAsheninka"
></object
> is to adjust the segment inventory, natural classes, and syllable patterns so that one gets most, if not all, words to syllabify correctly.</p
><p
><indexedItem
term="iCVPatternAlgorithm"
></indexedItem
><indexedItem
term="iParsingResult"
></indexedItem
>The main algorithm is as follows:</p
><ol
><li
>It does a left-to-right sweep of the word, trying to find the sequence of segments which covers the whole word. It uses the graphemes defined in the segment information to determine a match with a segment. Currently, it uses a longest match algorithm; that is, when two or more graphemes match, it uses the longest one. See <sectionRef
sec="sCVSegmentInventory"
></sectionRef
> for more on this. <indexedItem
term="iFailureCVSegmenter"
></indexedItem
>If it cannot find a sequence that covers the whole word, it reports an error of <object
type="tErrorMessage"
>Failure: could not parse into segments beginning at '<object
type="tItalic"
>some characters</object
></object
> and quits. The '<object
type="tItalic"
>some characters</object
>' part indicates the place in the word where it could not find a character or character sequence that matched any graphemes in any of the segments. Most likely, either there was a typo in the word or a grapheme is missing from some segment.</li
><li
>If it succeeded in finding a sequence of segments, it then performs a left-to-right sweep of the segments it posited, trying to find a sequence of natural classes that covers the entire sequence of segments. It uses the set of segments or natural (sub-)classes defined within a natural class to determine a match with a natural class. If two or more natural classes match, it tries each of them in turn. <indexedItem
term="iFailureCVNaturalClasser"
></indexedItem
>If it cannot find a sequence of natural classes that covers the entire sequence of posited segments, it reports an error of <object
type="tErrorMessage"
>Failure: could not parse into natural classes; did find classes '<object
type="tItalic"
>some classes</object
>' covering graphemes '<object
type="tItalic"
>some graphemes</object
>'</object
> and quits. The '<object
type="tItalic"
>some classes</object
>' part indicates the sequence of natural classes that were found and the '<object
type="tItalic"
>some graphemes</object
>' part indicates which graphemes were included in those natural classes. Hopefully this will help you figure out why other natural classes were not found for this word.</li
><li
>If it succeeded in finding a sequence of natural classes, it performs a left-to-right sweep of the sequence of the natural classes it posited, trying to find a sequence of syllable patterns that covers the entire sequence. It tries the syllable patterns in the order they are arranged in the <object
type="tCVSyllablePatterns"
></object
> view (see <sectionRef
sec="sCVSyllablePatterns"
></sectionRef
> below). <indexedItem
term="iFailureCVSyllables"
></indexedItem
>If it cannot find a sequence of syllable patterns that covers the entire sequence of posited natural classes, it reports an error of <object
type="tErrorMessage"
>Failure: could not parse natural classes into syllables</object
> and quits.</li
><li
>If it succeeded in finding a sequence of syllable patterns, it outputs the syllabification into the <object
type="tPredictedSyllableBreaks"
></object
> field and reports <object
type="tSuccessMessage"
></object
>.</li
></ol
><p
>We now give more information on the various views available in the user interface for the <object
type="tCVPatternApproach"
></object
>.</p
><section2
id="sCVSegmentInventory"
><secTitle
>CV segment inventory</secTitle
><p
><indexedItem
term="iCVSegments"
></indexedItem
>Make sure that what is in the <object
type="tCVSegmentInventory"
></object
> view covers all the segments you have in the orthography. <indexedItem
term="iAlgorithmSegment"
></indexedItem
>Currently, <object
type="tAsheninka"
></object
> uses a “longest match” algorithm for figuring out which segment a letter (or sequence of letters) belongs to. This could be a problem in some cases where a language has both codas and onsets and a given sequence of consonants might be ambiguous between various possibilities. So if you have a <langData
lang="lVernacular"
>k</langData
>, a <langData
lang="lVernacular"
>kl</langData
>, an <langData
lang="lVernacular"
>l</langData
>, and an <langData
lang="lVernacular"
>ll</langData
>, then something like <langData
lang="lVernacular"
>aklli</langData
> could be ambiguous between <langData
lang="lVernacular"
>ak.lli</langData
> and <langData
lang="lVernacular"
>akl.li</langData
>. The current version will only try <langData
lang="lVernacular"
>akl.li</langData
> because <langData
lang="lVernacular"
>kl</langData
> is the longest match in a left-to-right sweep. We do plan to add environments so one can limit certain graphemes to specified environments.</p
><p
>In the <object
type="tField"
>Segment</object
> field, key a letter or letters that will help you remember this segment. For example, a low central unrounded vowel might be keyed as <object
type="tKey"
>a</object
> while a voiceless alveopalatal affricate might be keyed as <object
type="tKey"
>t͡ʃ</object
> or as <object
type="tKey"
>ch</object
>.</p
><p
>The <object
type="tField"
>Description</object
> field is for your benefit. Key whatever helps you (and anyone looking at your data) know what the segment is. For example, you could key its phonetic or phonological description.</p
><p
>In the <object
type="tField"
>Graphemes</object
> field, key all the ways the particular segment appears in your orthography, including any upper case forms. Separate each one by a space.</p
></section2
><section2
id="sCVNaturalClasses"
><secTitle
>CV natural classes</secTitle
><p
><indexedItem
term="iCVNaturalClasses"
></indexedItem
>Make sure that in the <object
type="tCVNaturalClasses"
></object
> view, every segment is in a natural class. A given segment may be in more than one class.</p
><p
>The <object
type="tField"
>Name</object
> field is for you to define how this natural class will appear in syllable patterns. We suggest using something short and if there is more than one character in it, make the first one be capitalized and the rest be in lower case.<endnote
id="nCVClassName"
><p
>This is not required, it is just a suggestion.</p
></endnote
> The <object
type="tField"
>Description</object
> field is for your use to document anything special about this natural class.</p
><p
>The <object
type="tField"
>Segment or Natural Class</object
> field has a chooser button on the far right which looks like <img
src="resources/ChooserButton.png"
></img
>. Click on it to bring up a dialog box which lets you select segments and/or natural classes which belong to this natural class. Note that it is possible to insert one entire natural class within another natural class. For example, if you have a class of nasal consonants, you can include that class within another class that has all consonants.</p
></section2
><section2
id="sCVSyllablePatterns"
><secTitle
>CV syllable patterns</secTitle
><p
><indexedItem
term="iCVSyllablePatterns"
></indexedItem
>Use the <object
type="tCVSyllablePatterns"
></object
> view to create CV syllable patterns that cover the kinds of syllables you think the language has. Be sure to allow for vowel-initial syllables if there are vowel-initial syllables in the language.</p
><p
>The <object
type="tField"
>Name</object
> field is for you to define a short name for this syllable pattern. We suggest using something short. The <object
type="tField"
>Description</object
> field is for your use to document anything special about this syllable pattern.</p
><p
>The <object
type="tField"
>Natural Classes</object
> field shows the sequence of any natural classes this pattern consists of. It has a chooser button on the far right which looks like <img
src="resources/ChooserButton.png"
></img
>. Click on it to bring up a dialog box which lets you select natural classes which constitute this syllable pattern. This chooser consists of one or more drop-down boxes. Click on the drop-down arrow in the box. It will show you the list of possible natural classes to choose from. In addition, if this is the very first drop-down box or the last one currently being shown, it will also include “Word boundary”. When you choose “Word boundary”, the pattern shown above the drop-down box(es), will show “#” to indicate a word boundary.</p
><p
>Finally, the order in which the syllable patterns occur is important, as mentioned in <sectionRef
sec="sCVApproach"
></sectionRef
>. Recall that with the <object
type="tCVPatternApproach"
></object
>, as <object
type="tAsheninka"
></object
> parses a word, it tries to match the patterns in the order in which they appear. You control the order of the syllable patterns by clicking on a pattern in the middle pane and then using the up and down arrows to change its order. Note that the normal way of sorting by a column via clicking on a column header is disabled for this view.</p
></section2
><section2
id="sCVWords"
><secTitle
>CV words</secTitle
><p
><indexedItem
term="iCVWords"
></indexedItem
>In the <object
type="tCVWords"
></object
> view, the middle pane of the display shows all the words with three other columns:</p
><ol
><li
><object
type="tPredictedSyllableBreaks"
></object
></li
><li
><object
type="tCorrectSyllableBreaks"
></object
></li
><li
><object
type="tParserResult"
></object
></li
></ol
><pc
>When you click on a word in the middle pane, the same fields are shown on the right where you can edit them.</pc
><p
>Please note that until you either manually add words to the project or until you import a set of words, the list will be empty. See <sectionRef
sec="sWordsImport"
></sectionRef
> for how to import a set of words.</p
><p
>The <object
type="tPredictedSyllableBreaks"
></object
> column/field contains the result of the last time you ran the <object
type="tSyllabifyWords"
></object
> tool. When it is empty, it means either that the parser has never been invoked or that the parser failed to produce a result. If the parser failed to produce a result, the <object
type="tParserResult"
></object
> column/field should have some kind of explanation for where the parser ran into a problem (this will be in red).</p
><p
>When the <object
type="tPredictedSyllableBreaks"
></object
> column/field contains a result, it shows how this word was syllabified the last time you ran the <object
type="tSyllabifyWords"
></object
> tool, given the state of the segments, natural classes, and syllable patterns when it was invoked. When there is a result in this column/field, then the <object
type="tParserResult"
></object
> column/field should have “Success” (in green).</p
><p
>Remember that you can click on a column header to sort the contents of the column. If you click on the <object
type="tParserResult"
></object
> header, then any error messages should show at the top. You might find this useful when figuring out how to set the set of segments, natural classes, and syllable patterns to get a desired result.</p
><p
>The <object
type="tCorrectSyllableBreaks"
></object
> column/field contains what you have indicated to be the correct syllabification for this word. It may be filled in if you imported words from a <object
type="tParatext"
></object
> hyphenatedWords.txt file and that file indicated that this word's hyphenation had been approved. See <sectionRef
sec="sRemoveCorrectSyllabifcation"
></sectionRef
> for how to clear the set of <object
type="tCorrectSyllableBreaks"
></object
>. Otherwise, this column/field is expected to be blank until you either manually enter the correct syllabification or run the <object
type="tConvertPredictedToCorrectSyllabifcation"
></object
> tool by using <object
type="tMenuItem"
>Tools / Convert predicted to correct syllabification</object
> menu item or clicking on the <img
src="resources/ConvertPredictedToCorrect.png"
></img
> tool bar button.</p
><p
>When you run the <object
type="tConvertPredictedToCorrectSyllabifcation"
></object
> tool, it brings up a dialog box listing all the words which have a non-empty <object
type="tPredictedSyllableBreaks"
></object
> field. See <sectionRef
sec="sConvertPredictedToCorrect"
></sectionRef
> for more on this.</p
></section2
><section2
id="sCVTryAWord"
><secTitle
>CV Try a Word</secTitle
><p
><indexedItem
term="iCVTryAWord"
></indexedItem
><indexedItem
term="iTryAWord"
></indexedItem
>There are times when it may be difficult to know just why a given word is not syllabifying correctly. That's where the <object
type="tTryAWord"
></object
> dialog box can be useful. To see it, use the <object
type="tMenuItem"
>Parser / Try a Word</object
> menu item. This brings up a dialog box like the one shown in example <exampleRef
letter="xCVTryAWord"
num="xCVTryAWord"
></exampleRef
>. (Note: unlike most dialog boxes, you can keep the <object
type="tTryAWord"
></object
> dialog box open while still editing other views in the main window. Unfortunately, the minimize button does not currently work so you cannot minimize the dialog, but you can drag it around and resize it.)</p
><example
num="xCVTryAWord"
><chart
><img
src="resources/CVTryAWord1.png"
width="500"
></img
></chart
></example
><p
>You can key a word to try in the text box. By default, <object
type="tAsheninka"
></object
> shows the current word selected in the <object
type="tCVWords"
></object
> view (if you are showing that view) or the last word you used (or nothing if you've never used <object
type="tTryAWord"
></object
> before and are not showing the <object
type="tCVWords"
></object
> view).</p
><p
>When you either press the <object
type="tKey"
>Enter</object
> key or click on the <object
type="tButton"
>Try it</object
> button, <object
type="tAsheninka"
></object
> will try to parse the word in the text box and report the result in the Results portion of the dialog box.</p
><p
>For the <object
type="tCVPatternApproach"
></object
>, there are at most three steps that are tried:</p
><ol
><li
>Parsing into segments.</li
><li
>Parsing segments into natural classes.</li
><li
>Parsing natural classes into syllables.</li
></ol
><p
>The results portion always shows the parsing into segments. If this succeeded, then it also shows the parsing of segments into natural classes. If this succeeded, it shows the result of parsing natural classes into syllables. Successful steps are shown in <object
type="tGreen"
></object
> while unsuccessful ones are shown in <object
type="tRed"
></object
>. An example of a successful parse is shown in example <exampleRef
letter="xCVTryAWordachinmeh1"
num="xCVTryAWordachinmeh1"
></exampleRef
>.</p
><example
num="xCVTryAWordachinmeh1"
><chart
><img
src="resources/CVTryAWord2.png"
width="500"
></img
></chart
></example
><p
>The parsing into segments part shows which grapheme was matched with what segment, Example <exampleRef
letter="xCVTryAWordGraphemeDiffererent"
num="xCVTryAWordGraphemeDiffererent"
></exampleRef
> shows a case where the grapheme differs from the segment in shape.</p
><example
num="xCVTryAWordGraphemeDiffererent"
><chart
><img
src="resources/CVTryAWordGraphemeDifferent.png"
></img
></chart
></example
><p
>The parsing segments into natural classes part shows which natural classes were matched. Sometimes a given segment may be in more than one natural class. In that case, the possible natural classes are shown inside of curly braces as shown in example <exampleRef
letter="xCVTryAWordMultipleNaturalClasses"
num="xCVTryAWordMultipleNaturalClasses"
></exampleRef
>.</p
><example
num="xCVTryAWordMultipleNaturalClasses"
><chart
><img
src="resources/CVTryAWordMultipleNaturalClasses.png"
></img
></chart
></example
><p
>Scrolling the results window down shows the last part:</p
><example
num="xCVTryAWordachinmeh2"
><chart
><img
src="resources/CVTryAWord3.png"
width="500"
></img
></chart
></example
><pc
>In the last part, it shows which syllable patterns were tried in the order they were tried. Successful ones are shown in <object
type="tGreen"
></object
> (and begin with a small box with a plus sign in it). These will always be the last one shown because <object
type="tAsheninka"
></object
> stops looking whenever it finds a successful match. Failed ones are shown in <object
type="tRed"
></object
> (and begin with a small box with a minus sign in it). Whenever a particular pattern matched the word at a particular point in the parsing process but it did not ultimately lead to a successful parse, it is shown in <object
type="tBlue"
></object
> (and begins with a small box with a plus sign in it).</pc
><p
>To examine a particular path, click on the small box with a plus sign in it. This will expand that path and show the next set of syllable patterns tried, in the order they were tried.</p
><p
>As mentioned above, whenever one of the three steps fails, there is an error message shown for that step (and no following steps will be tried).</p
><p
><indexedItem
term="iFailureCVSegmenter"
></indexedItem
>For example, if a word contains a grapheme that is not defined in any segment, when trying to parse the word into segments, it will show a message such as what is in example <exampleRef
letter="xCVTryAWordGraphemeError"
num="xCVTryAWordGraphemeError"
></exampleRef
>.</p
><example
num="xCVTryAWordGraphemeError"
><chart
><object
type="tErrorMessageText"
>Failure: could not parse into segments beginning at 'qap'.</object
></chart
></example
><pc
>In this case, the word was <langData
lang="lVernacular"
>aanguqap</langData
> but the <langData
lang="lVernacular"
>q</langData
> was not defined in any segment. Note that it shows where the problem was initially found.</pc
><p
><indexedItem
term="iFailureCVNaturalClasser"
></indexedItem
>As another example, if a word contains a segment that is not in any natural class, it will display a message such as what is shown in example <exampleRef
letter="xCVTryAWordNCFailure"
num="xCVTryAWordNCFailure"
></exampleRef
>.</p
><example
num="xCVTryAWordNCFailure"
><chart
><object
type="tErrorMessageText"
>Failure: could not parse into natural classes; did find classes 'V, C' covering graphemes 'am'.</object
></chart
></example
><pc
>In this case, the word was <langData
lang="lVernacular"
>ambu</langData
>, but no natural class has the segment <langData
lang="lVernacular"
>b</langData
> in it. So when it tried to find a natural class for <langData
lang="lVernacular"
>b</langData
>, it failed. Notice that is does show what was found. (If the segment is the first item in the word, the found classes will be <object
type="tErrorMessageText"
>''</object
> and the covered graphemes will be <object
type="tErrorMessageText"
>''</object
>.)</pc
><p
><indexedItem
term="iFailureCVSyllables"
></indexedItem
>For the final step, if the sequence of natural classes could not be parsed into syllables per the ordered syllable patterns, then the following message is reported:</p
><example
num="xCVTryAWordSylFailure"
><chart
><object
type="tErrorMessageText"
>Failure: could not parse natural classes into syllables</object
></chart
></example
><pc
>What follows this is an explanatory paragraph as noted above for example <exampleRef
letter="xCVTryAWordachinmeh2"
num="xCVTryAWordachinmeh2"
></exampleRef
> and then the list of syllable patterns tried. In one project, this looked liked what is in example <exampleRef
letter="xCVTryAWordFailedSyl1"
num="xCVTryAWordFailedSyl1"
></exampleRef
> for the word <langData
lang="lVernacular"
>yanjkuik</langData
>.</pc
><example
num="xCVTryAWordFailedSyl1"
><chart
><img
height="200"
src="resources/CVTryAWordFailedSyl1.png"
></img
></chart
></example
><pc
>Notice that none of the patterns are in green. Four are in red and two are in blue. Recall from above that this means that none of the red patterns matched the beginning of the sequence of natural classes (which was <object
type="tGreenText"
>C, V, C, C, K, C</object
>). The two blue ones did match the beginning of the sequence, but did not ultimately lead to a successful parse. Example <exampleRef
letter="xCVTryAWordFailedSyl2"
num="xCVTryAWordFailedSyl2"
></exampleRef
> shows what it looked like when opening the second blue pattern (<object
type="tBlueText"
>C, V, C</object
>).</pc
><example
num="xCVTryAWordFailedSyl2"
><chart
><img
height="200"
src="resources/CVTryAWordFailedSyl2.png"
></img
></chart
></example
><pc
>Notice that all the embedded patterns are in red: none of them matched the beginning of the natural class sequence after removing the initial <object
type="tBlueText"
>C, V, C</object
> part that had matched (i.e., with <object
type="tGreenText"
>C, K, C</object
>).</pc
></section2
><section2
id="sCVPredicitedVsCorrect"
><secTitle
>Predicted vs.​ correct CV words</secTitle
><p
><indexedItem
term="iCVPredictedVsCorrect"
></indexedItem
><indexedItem
term="iCVPredictedSyllabificationCompare"
></indexedItem
>The <object
type="tCVPredictedVsCorrectWords"
></object
> view shows any words which have both a predicted value and a correct value and, in addition, the two values differ. This is intended to give you a way to quickly see how the predictions of the current set of segments, natural classes, and syllable patterns differ from the expected results. In this view, by the way, the predicted and correct words are aligned in pairs with the predicted syllabification immediately above the correct syllabification. This is an attempt to make it easier to see the differences between the two.</p
></section2
></section1
><section1
id="sSonorityHiearchyApproach"
><secTitle
>Sonority hierarchy approach</secTitle
><p
><indexedItem
term="iSonorityHierarchyApproach"
></indexedItem
>This approach has not been implemented yet.</p
></section1
><section1
id="sONCApproach"
><secTitle
>Onset-nucleus-coda approach</secTitle
><p
><indexedItem
term="iONCApproach"
></indexedItem
>This approach has not been implemented yet.</p
></section1
><section1
id="sMoriacApproach"
><secTitle
>Moraic approach</secTitle
><p
><indexedItem
term="iMoraicApproach"
></indexedItem
>This approach has not been implemented yet.</p
></section1
><section1
id="sNuclearProjectionApproach"
><secTitle
>Nuclear projection approach</secTitle
><p
><indexedItem
term="iNuclearProjectionApproach"
></indexedItem
>This approach has not been implemented yet.</p
></section1
><section1
id="sOTApproach"
><secTitle
>Optimality theory approach</secTitle
><p
><indexedItem
term="iOTApproach"
></indexedItem
>This approach has not been implemented yet.</p
></section1
><section1
id="sConvertPredictedToCorrect"
><secTitle
>Converting predicted syllabification to correct syllabification</secTitle
><p
><indexedItem
term="iCVPredictedSyllabificationConvert"
></indexedItem
>When you run the <object
type="tConvertPredictedToCorrectSyllabifcation"
></object
> tool either by using the <object
type="tMenuItem"
>Tools / Convert predicted to correct syllabification</object
> menu item or by clicking on the <img
src="resources/ConvertPredictedToCorrect.png"
></img
> tool bar button, it brings up a dialog box listing all the words which have a non-empty <object
type="tPredictedSyllableBreaks"
></object
> field. You can select which words should be converted by manually checking the box before them<endnote
id="nCheckingBox"
><p
>To check the box, either click in it or click in the row and press the space bar.</p
></endnote
> or by clicking on the checkbox in the header row and choosing to “Select All”, "Clear All”, or “Toggle”:</p
><ol
><li
>“Select All” checks every word.</li
><li
>“Clear All” unchecks every word.</li
><li
>“Toggle” makes every word that is checked be unchecked and every word that is unchecked be checked.</li
></ol
><p
>When you click on the OK button, <object
type="tAsheninka"
></object
> will copy the value in the <object
type="tPredictedSyllableBreaks"
></object
> field of every word that is checked to the corresponding <object
type="tCorrectSyllableBreaks"
></object
> field.</p
></section1
><section1
id="sProjectManagement"
><secTitle
>Project management</secTitle
><p
><indexedItem
term="iPMBackup"
></indexedItem
><indexedItem
term="iPMRestore"
></indexedItem
>Feel free to make frequent (labeled) backups via the <object
type="tMenuItem"
>File / Project Management / Back up this project</object
> menu item. It will bring up a dialog box like the one shown in example <exampleRef
letter="xBackUpProject"
num="xBackUpProject"
></exampleRef
>. Please give it a descriptive label so you can later identify the state of your project when you made the backup. (You can key language data if you wish.) You won't see the label on the file name, though. Rather, you'll see it when you go to the <object
type="tMenuItem"
>File / Project Management / Restore a project</object
> menu item.</p
><example
num="xBackUpProject"
><chart
><img
src="resources/BackupProject.png"
width="400"
></img
></chart
></example
><p
>When you restore a project, you will see a dialog box something like the one shown in example <exampleRef
letter="xRestoreAProject"
num="xRestoreAProject"
></exampleRef
>.</p
><example
num="xRestoreAProject"
><chart
><img
src="resources/RestoreAProject.png"
width="600"
></img
></chart
></example
><p
>The backups you have made for this project will be shown in the list. The content in the Description column is the description you keyed while making the backup.</p
><p
>The idea here is that you can make a backup, try something else (e.g., add a segment or class; or re-order the syllable patterns or add a new one), and see how it goes. If it's worse, just restore to the previous state. If it's better, make a backup of that and go on.</p
></section1
><section1
id="sWords"
><secTitle
>Importing and exporting words</secTitle
><p
>When using <object
type="tAsheninka"
></object
>, of course, you need words to parse. Once they are parsed and you have set the correct syllabifications for them (see <sectionRef
sec="sConvertPredictedToCorrect"
></sectionRef
>), you may want to export the set of words to be used by a typesetting tool. Such a tool can use the syllabified words as a list of words with discretionary hyphens so that it can know when to hyphenate long words at ends of lines.</p
><section2
id="sWordsImport"
><secTitle
>Import words</secTitle
><p
><indexedItem
term="iImport"
></indexedItem
><object
type="tAsheninka"
></object
> allows you to import a list of words in the following forms:</p
><ol
><li
><indexedItem
term="iImportTextFile"
></indexedItem
>A text file with one word per line</li
><li
><indexedItem
term="iImportParaTExt"
></indexedItem
>A word list exported from <object
type="tParatext"
></object
></li
><li
><indexedItem
term="iImportParaTExt"
></indexedItem
>The hyphenatedWords.txt file from <object
type="tParatext"
></object
></li
><li
><indexedItem
term="iImportFLEx"
></indexedItem
>A word list exported from <object
type="tTool"
>FieldWorks Language Explorer</object
> (aka FLEx) (in tab-delimited form)</li
></ol
><p
>You can use any or all of these to add words to <object
type="tAsheninka"
></object
>'s list of words. A given word form will only be inserted once. By “word form” we mean that word pairs such as <langData
lang="lVernacular"
>achto</langData
> and <langData
lang="lVernacular"
>Achto</langData
> will be considered different since their capitalization is distinct.</p
><p
>To import a word list, use <object
type="tMenuItem"
>File / Import Words</object
> menu item and then choose the type of import to use. In each case, a standard file open dialog will appear. Find the file that has the format you need, choose it, and click on “Open”. Depending on the number of words in the imported file, this may take a while to complete.</p
><p
>If you are working on a word list found in <object
type="tParatext"
></object
>, we recommend using the hyphenatedWords.txt file method. This file includes both upper and lower case forms of words and also will include any hyphenation the <object
type="tParatext"
></object
> user has manually approved. At least with some versions of <object
type="tParatext"
></object
>, this file can be found in the “My Paratext Projects” folder and then in the folder of your project name.</p
><p
>Newly added words will appear in the <object
type="tCVWords"
></object
> view with a <object
type="tParserResult"
></object
> showing <object
type="tErrorMessage"
>Untested</object
>. This means that the parser has not yet been run on the word.</p
></section2
><section2
id="sWordsExport"
><secTitle
>Export words</secTitle
><p
><indexedItem
main="yes"
term="iExport"
></indexedItem
>When you want to export the word list in <object
type="tAsheninka"
></object
> to some kind of typesetting tool, use the <object
type="tMenuItem"
>File / Export Hyphenated Words</object
> menu item. The list of hyphenated words can be exported in three formats:</p
><ol
><li
><indexedItem
main="yes"
term="iExportInDesign"
></indexedItem
><indexedItem
main="yes"
term="iExportTextFile"
></indexedItem
>Export for <object
type="tInDesign"
></object
> (simple list)</li
><li
><indexedItem
main="yes"
term="iExportParaTExt"
></indexedItem
>Export for <object
type="tParatext"
></object
> (hyphenatedWords.txt)</li
><li
><indexedItem
main="yes"
term="iExportXLingPaper"
></indexedItem
>Export for <object
type="tXLingPaper"
></object
> (hyphenations exception file)</li
></ol
><p
><object
type="tAsheninka"
></object
> exports hyphenated words in the following way:</p
><ol
><li
>When the word has a value in <object
type="tCorrectSyllableBreaks"
></object
>, that value is used.</li
><li
>If <object
type="tCorrectSyllableBreaks"
></object
> is empty, then if there is a value in <object
type="tPredictedSyllableBreaks"
></object
>, it uses that value.</li
><li
>Otherwise, it does not export the word.</li
></ol
><pc
><indexedItem
term="iHPDiscretionaryHyphen"
></indexedItem
>It also will replace the periods used to demarcate syllables with whatever you have set as the discretionary hyphen character(s) in the hyphenation parameters (see <sectionRef
sec="sHyphenationParameters"
></sectionRef
>). By default, <object
type="tAsheninka"
></object
> uses an equals sign for both <object
type="tParatext"
></object
> and <object
type="tInDesign"
></object
> and a hyphen for the <object
type="tXLingPaper"
></object
> output.</pc
><p
><indexedItem
term="iHPStart"
></indexedItem
><indexedItem
term="iHPStop"
></indexedItem
>Further, <object
type="tAsheninka"
></object
> will not insert a discretionary hyphen if it appears too close to the front or too close to the end of a word, depending on the hyphenation parameters set. By default, the <object
type="tInDesign"
></object
> export uses zero characters from the front and zero characters from the end (i.e., every potential discretionary hyphen position is used).<endnote
id="nInDesign"
><p
>This is because the <object
type="tInDesign"
></object
> program has its own way of letting the typesetter control where discretionary hyphens will be used.</p
></endnote
> By default, both the <object
type="tParatext"
></object
> and <object
type="tXLingPaper"
></object
> export methods limit discretionary hyphens from two characters from front and two characters from the back.</p
></section2
></section1
><section1
id="sOtherTools"
><secTitle
>Other tools</secTitle
><p
><object
type="tAsheninka"
></object
> also offers three other tools not previously covered.</p
><section2
id="sFindWord"
><secTitle
>Find a word</secTitle
><p
><indexedItem
term="iFindAWord"
></indexedItem
>Use the <object
type="tMenuItem"
>Tools / Find Word</object
> menu item or key <object
type="tKey"
>Ctrl F</object
> or click on the <img
src="resources/FindWord.png"
></img
> button on the toolbar to find a particular word. This brings up a dialog box which allows you to start typing the word you are looking for. As you type, it has a drop down area showing all words which contain the sequence of characters you have typed. Note that it shows all words which have this sequence anywhere in them, not just at the beginning. For example, with one project when I typed “<object
type="tKey"
>ach</object
>”, what is in example <exampleRef
letter="xFindWordSample"
num="xFindWordSample"
></exampleRef
> showed.</p
><example
num="xFindWordSample"
><chart
><img
src="resources/FindWordSample.png"
></img
></chart
></example
><p
>This can be very useful not only for finding a particular word, but also for looking for particular sequences of characters.</p
></section2
><section2
id="sRemoveAllWords"
><secTitle
>Remove all words</secTitle
><p
><indexedItem
term="iRemoveWords"
></indexedItem
>Use the <object
type="tMenuItem"
>Tools / Remove all words</object
> menu item to completely clear the list of words in the <object
type="tCVWords"
></object
> view. When you invoke this menu item, it will show the dialog box shown in example <exampleRef
letter="xRemoveAllWords"
num="xRemoveAllWords"
></exampleRef
>.</p
><example
num="xRemoveAllWords"
><chart
><img
height="200"
src="resources/RemoveAllWords.png"
></img
></chart
></example
><p
>When you click on the <object
type="tButton"
>Yes</object
> button, <object
type="tAsheninka"
></object
> will then show you the backup dialog box (see <sectionRef
sec="sProjectManagement"
></sectionRef
>). When you have done the backup, <object
type="tAsheninka"
></object
> will immediately remove all the words from the list of words.</p
><p
>If, instead, you click on the <object
type="tButton"
>No</object
> button, <object
type="tAsheninka"
></object
> will immediately remove all the words from the list of words.</p
><p
>Note that when the words are removed, it will happen whether or not the <object
type="tCVWords"
></object
> view is currently being shown. It usually happens very quickly.</p
><p
>If you click on the <object
type="tButton"
>Cancel</object
> button (or close the dialog box using the X in the red area), the dialog box will exit and nothing will change.</p
></section2
><section2
id="sRemoveCorrectSyllabifcation"
><secTitle
>Remove correct syllable breaks in all words</secTitle
><p
><indexedItem
term="iRemoveCorrectSyllabificationAllWords"
></indexedItem
>Use the <object
type="tMenuItem"
>Tools / Remove correct syllable breaks in all words</object
> menu item to completely clear the <object
type="tCorrectSyllableBreaks"
></object
> column in the <object
type="tCVWords"
></object
> view. When you invoke this menu item, it will show the dialog box shown in example <exampleRef
letter="xRemoveCorrectSyllabification"
num="xRemoveCorrectSyllabification"
></exampleRef
>.</p
><example
num="xRemoveCorrectSyllabification"
><chart
><img
height="200"
src="resources/RemoveCorrectSyllabification.png"
></img
></chart
></example
><p
>Like the dialog box for removing all words in <sectionRef
sec="sRemoveAllWords"
></sectionRef
>, you are asked whether or not to make a backup. When you click on the <object
type="tButton"
>Yes</object
> button, <object
type="tAsheninka"
></object
> will then show you the backup dialog box (see <sectionRef
sec="sProjectManagement"
></sectionRef
>). When you have done the backup, <object
type="tAsheninka"
></object
> will immediately remove all the <object
type="tCorrectSyllableBreaks"
></object
> forms from the list of words.</p
><p
>If, instead, you click on the <object
type="tButton"
>No</object
> button, <object
type="tAsheninka"
></object
> will immediately remove all the <object
type="tCorrectSyllableBreaks"
></object
> forms from the list of words.</p
><p
>Note that when the <object
type="tCorrectSyllableBreaks"
></object
> forms are removed, it will happen whether or not the <object
type="tCVWords"
></object
> view is currently being shown. It usually happens very quickly.</p
><p
>If you click on the <object
type="tButton"
>Cancel</object
> button (or close the dialog box using the X in the red area), the dialog box will exit and nothing will change.</p
></section2
><section2
id="sCompareImplementations"
><secTitle
>Compare two implementations</secTitle
><p
><indexedItem
term="iCompare2Implementations"
></indexedItem
><object
type="tAsheninka"
></object
> offers a way to more easily see what some changes to an approach have on how the words are syllabified. Use the <object
type="tMenuItem"
>Tools / Compare Implementations</object
> menu item to do this. It brings up a dialog box which looks like what is in example <exampleRef
letter="xCompareImplementationsInitial"
num="xCompareImplementationsInitial"
></exampleRef
>.</p
><example
num="xCompareImplementationsInitial"
><chart
><img
src="resources/CompareImplementationsInitial.png"
></img
></chart
></example
><p
>You can compare the current implementation (i.e., what is showing in the user interface right now) with what is in a backup file (see <sectionRef
sec="sProjectManagement"
></sectionRef
>) or you can compare two different backups. As you can see in example <exampleRef
letter="xCompareImplementationsInitial"
num="xCompareImplementationsInitial"
></exampleRef
>, the current implementation is set by default. To compare two backups, click on the <object
type="tField"
>Choose a backup</object
> radio button.</p
><p
>Whenever you need to select a backup file, click on the <object
type="tField"
>Browse</object
> button. This will bring up the <object
type="tField"
>Restore a Project</object
> dialog. Choose the backup you want and click OK.</p
><p
>When you have chosen the two implementations to compare, click on the “Compare” button. Depending on how many differences there are, the comparison process can take quite a long time so please be patient. When it is done, a report is shown in the bottom part of the dialog. When I did this for one project, I got what is shown in example <exampleRef
letter="xCompareImplementationsResult"
num="xCompareImplementationsResult"
></exampleRef
>.</p
><example
num="xCompareImplementationsResult"
><chart
><img
src="resources/CompareImplementationsResult.png"
></img
></chart
></example
><p
>The dialog box will stay visible until you close it (e.g., by clicking on the “Cancel” button). This lets you examine the report while still being able to make changes to the data in the user interface.</p
></section2
></section1
><backMatter
><appendix
id="aAsheninka"
><secTitle
>Why is it called <object
type="tAsheninka"
></object
>?</secTitle
><p
>This syllable parsing program is called <object
type="tAsheninka"
></object
> for historic reasons.  (The word is pronounced <langData
lang="lVernacular"
>a.ˈʃɛ.nɪŋ.ka</langData
>.)</p
><p
>In late 1983 my family and I were living in the jungles of Peru and David Payne came and asked me if I would create a <object
type="tTool"
>Consistent Changes</object
> table for him that would insert discretionary hyphens in Asheninka text.<endnote
id="nCC"
><p
>A more current version of this program is <citation
ref="rCC"
></citation
>.</p
></endnote
> The algorithm he suggested was the CV Patterns approach (see <sectionRef
sec="sCVApproach"
></sectionRef
>). Asheninka has long words and typesetting material in that language would improve readability with such a table. In 1984 I wrote such a table.</p
><p
>While it was functional, it ran slowly. I then wrote the <object
type="tTool"
>Hyphen</object
> program (<citation
paren="none"
ref="rDocPrepAids"
></citation
>) to improve the efficiency. It implemented the same basic approach. Amazingly, the <object
type="tTool"
>Hyphen</object
> program is still being used (albeit occasionally) today.</p
><p
>Because of this beginning, I chose to call this tool <object
type="tAsheninka"
></object
>. The program icon (shown in example <exampleRef
letter="xCushma"
num="xCushma"
></exampleRef
> below) is the kind of material used for clothing by Asheninka people.<endnote
id="nCushmaImage"
><p
>This image was gratefully taken from <link
href="http://www.ecotribal.com/en/shop/ashaninka-cushma-8"
>here</link
> on 12 November, 2015.</p
></endnote
></p
><example
num="xCushma"
><chart
><img
src="CushmaSmall.jpg"
></img
></chart
></example
></appendix
><endnotes
></endnotes
><xi:include
href="CommonReferences.xml"
xpointer="element(/1)"
xmlns:xi="http://www.w3.org/2001/XInclude"
></xi:include
><index
></index
></backMatter
><xi:include
href="Languages.xml"
xpointer="element(/1)"
xmlns:xi="http://www.w3.org/2001/XInclude"
></xi:include
><xi:include
href="Types.xml"
xpointer="element(/1)"
xmlns:xi="http://www.w3.org/2001/XInclude"
></xi:include
><xi:include
href="IndexTerms.xml"
xpointer="element(/1)"
xmlns:xi="http://www.w3.org/2001/XInclude"
></xi:include
></lingPaper
><xi:include
href="SILInternationalPaperStylesheet.xml"
xpointer="element(/1)"
xmlns:xi="http://www.w3.org/2001/XInclude"
></xi:include
></styledPaper
></xlingpaper
>
